# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

PWSW (PipeWire Switcher) is a Rust daemon that automatically switches PipeWire audio sinks based on active windows in Wayland compositors. It uses standard Wayland protocols (wlr-foreign-toplevel-management and plasma-window-management) to monitor window events and PipeWire native tools (pw-dump, pw-metadata, pw-cli) for audio control.

**IMPORTANT**: This codebase was entirely generated by LLMs without peer review from experienced Rust developers. However, it has undergone comprehensive code review and pedantic clippy cleanup (154 warnings ‚Üí 7 acceptable). Exercise caution when making changes and validate thoroughly.

## Code Quality Standards

**All new code must adhere to these standards:**

### Clippy Compliance
```bash
# Check for all clippy warnings (should pass with only 7 acceptable warnings)
cargo clippy --all-targets

# Pedantic mode (should have only 7 warnings - see below)
cargo clippy --all-targets -- -W clippy::pedantic
```

**Acceptable Pedantic Warnings (7 total):**
- 2√ó `struct_excessive_bools` ‚Üí Settings struct legitimately needs 6 independent boolean flags
- 1√ó `too_many_lines` ‚Üí Daemon event loop (146 lines) is cohesive and hard to split meaningfully
- 2√ó `items_after_statements` ‚Üí Constants defined in spawn block for scoping
- 2√ó `needless_pass_by_value` ‚Üí Wayland `Connection` must be moved, not borrowed (protocol requirement)

**All other clippy warnings must be fixed before merging.**

### Documentation Requirements

Every public function returning `Result` must have:
```rust
/// Brief description of what the function does
///
/// # Errors
/// Clear description of when/why this returns an error
pub fn example() -> Result<()> { ... }
```

Functions that may panic (using `expect()` or similar) must document:
```rust
/// # Panics
/// Description of panic conditions (even if "should never happen")
```

Technical terms must use backticks in documentation:
- ‚úÖ `PipeWire`, `app_id`, `IPC`, `XDG_RUNTIME_DIR`
- ‚ùå PipeWire, app_id, IPC, XDG_RUNTIME_DIR

### Code Quality Patterns

**Error Handling:**
- Use `Result` and `Context` for error propagation
- Avoid `.expect()` in production paths (only for defensive checks that should never fail)
- Document all panic conditions with `# Panics`

**Efficiency:**
- Prefer `clone_from()` over reassignment: `string.clone_from(&other)` instead of `string = other.clone()`
- Use `map_or()` / `map_or_else()` instead of `map().unwrap_or()`
- Use `is_some_and()` instead of `map().unwrap_or(false)`
- Dereference before `to_string()`: `(*str_ref).to_string()` instead of `str_ref.to_string()`

**Modern Patterns:**
- Use `let-else` for early returns: `let Ok(value) = result else { return false };`
- Derive `Copy` for simple enums when possible
- Use `#[must_use]` on functions that return important values

### Security Practices

**Command Execution:**
- Always use proper JSON serialization (`serde_json::json!`) instead of string formatting
- Never construct shell commands with user input
- Validate all external command outputs

**IPC Security:**
- Unix sockets must have `0o600` permissions (user-only access)
- Validate message sizes before allocation
- Use length-prefixed protocol to prevent injection attacks

**File Operations:**
- Use `path.display()` instead of Debug formatting (`{:?}`) in user-facing messages
- Set explicit permissions on created files/sockets
- Clean up stale files before binding sockets

## Build Commands

### Development
```bash
# Build in debug mode
cargo build

# Build with optimizations
cargo build --release

# Check without building
cargo check

# Run tests (if any exist)
cargo test

# Run clippy for linting
cargo clippy

# Format code
cargo fmt
```

### Installation
```bash
# Install to ~/.cargo/bin/
cargo install --path .

# The binary will be at:
# - Debug: target/debug/pwsw
# - Release: target/release/pwsw
```

### Running
```bash
# Start daemon in foreground (for debugging)
cargo run -- daemon --foreground

# Start daemon in background
cargo run -- daemon

# Other commands (require running daemon for IPC commands)
cargo run -- status
cargo run -- list-sinks
cargo run -- validate
```

## Architecture

### Core Components

**Daemon Mode (`daemon.rs`)**
- Main event loop using tokio::select! to multiplex:
  - Compositor window events (via mpsc channel from Wayland thread)
  - IPC requests from CLI clients (via Unix socket)
  - Shutdown signals (Ctrl-C or IPC shutdown request)
- Owns the State and manages the lifecycle

**State Management (`state.rs`)**
- Tracks active windows that matched rules (HashMap<u64, ActiveWindow>)
- Implements rule matching logic (app_id + optional title regex)
- Priority system: most recently opened matching window wins
- When windows close or stop matching, determines target sink from remaining active windows
- Falls back to default sink when no rules match

**IPC Infrastructure (`ipc.rs`)**
- Unix socket-based client-server communication
- Length-prefixed JSON protocol (4-byte big-endian length + JSON payload)
- Socket location: $XDG_RUNTIME_DIR/pwsw.sock or /tmp/pwsw-$USER.sock
- Socket permissions: 0o600 (user-only access for security)
- Automatic stale socket cleanup on daemon start (500ms health check timeout)
- Request types: Status, Reload, ListWindows, TestRule, Shutdown
- Response types: Status, Ok, Error, Windows, RuleMatches

**Compositor Abstraction (`compositor/mod.rs`)**
- Protocol detection via Wayland registry scan (prefers wlr-foreign-toplevel over plasma)
- Spawns dedicated std::thread for Wayland event loop (Wayland is not async-friendly)
- Sends WindowEvent enum (Opened, Changed, Closed) to tokio runtime via unbounded mpsc channel
- Implementations:
  - `wlr_toplevel.rs`: wlr-foreign-toplevel-management protocol (Sway, Hyprland, Niri, River, etc.)
  - `plasma.rs`: plasma-window-management protocol (KDE Plasma/KWin)

**PipeWire Integration (`pipewire.rs`)**
- Parses pw-dump JSON output for sinks, devices, profiles, and metadata
- Active sinks: Audio/Sink nodes currently available
- Profile sinks: Predicted node names for sinks that require profile switching
- Profile switching workflow:
  1. Call pw-cli to switch device profile (uses proper JSON serialization)
  2. Wait with retries (150ms √ó 5 max) for new sink node to appear
  3. Set as default with pw-metadata
- Node name prediction: `alsa_output.{device_suffix}.{profile_suffix}`
- **Concurrency**: Profile switching is not thread-safe for concurrent switches on the same device

**Configuration (`config.rs`)**
- TOML format at $XDG_CONFIG_HOME/pwsw/config.toml
- Validation rules:
  - Exactly one default sink required
  - No duplicate sink names or descriptions
  - All rule sink references must resolve (by position, desc, or name)
  - Log level must be valid
- Creates default config if none exists
- Sink references support: 1-indexed position, description, or node name

### Data Flow

1. **Window Event Flow**:
   - Wayland compositor emits protocol events
   - Compositor thread receives and converts to WindowEvent
   - Sent via mpsc channel to daemon's tokio runtime
   - State processes event and determines if sink switch is needed
   - PipeWire::activate_sink() called if switch required

2. **IPC Request Flow**:
   - CLI client connects to Unix socket
   - Sends length-prefixed JSON request
   - Daemon spawns tokio task to handle request
   - Task reads current state snapshot (no shared mutable state)
   - Response written back to same socket

3. **Profile Switching Flow**:
   - Check if sink is active (quick path: just set default)
   - If not active, check profile_sinks for predicted name
   - Switch device profile with pw-cli
   - Poll with retries for new sink node to appear
   - Set as default with pw-metadata

### Threading Model

- **Main Tokio Runtime**: Runs daemon event loop, IPC server, signal handlers
- **Wayland Thread**: Dedicated std::thread for Wayland event loop (blocking, not async)
- **IPC Handler Tasks**: Spawned tokio tasks for each IPC connection (non-blocking)

State is owned by the main loop. IPC handlers clone only what they need (uptime, current_sink_name, tracked windows list) to avoid shared mutable state.

### Key Design Patterns

**Priority-based sink switching**: Most recent matching window wins. When it closes, next most recent takes over.

**Predicted node names**: Profile sinks use string manipulation to predict the node name before switching (enables config validation).

**Protocol abstraction**: WindowEvent enum allows adding new compositor protocols without changing daemon logic.

**No config hot-reload**: "Reload" command validates config but requires daemon restart for changes to take effect. This avoids complex state synchronization.

## Configuration Notes

### Finding Window App IDs and Titles

Different compositors provide different tools:
- Sway/River/wlroots: `swaymsg -t get_tree`
- Hyprland: `hyprctl clients`
- Niri: `niri msg windows`
- KDE Plasma: KDE's window inspector
- Or use: `pwsw list-windows` (while daemon is running)

### Regex Pattern Syntax

Window rules support full Rust regex syntax:
- `"firefox"` - matches anywhere in string
- `"^steam$"` - exact match only
- `"^(mpv|vlc)$"` - matches mpv OR vlc
- `"(?i)discord"` - case insensitive

Both app_id and title support regex. If title is omitted, any title matches.

### Sink Icon Auto-detection

Icons are auto-detected from sink descriptions:
- "HDMI" ‚Üí video-display
- "headphone" ‚Üí audio-headphones
- "speaker" ‚Üí audio-speakers
- "analog" ‚Üí audio-card
- Override with explicit `icon = "..."` in config

## Testing

When making changes to window matching or state management logic, test with:
```bash
# Start daemon in foreground to see logs
pwsw daemon --foreground

# In another terminal:
pwsw list-windows        # See what windows daemon knows about
pwsw test-rule "^mpv$"   # Test regex patterns
pwsw status              # Check current state
```

For PipeWire integration changes:
```bash
pwsw list-sinks          # See active and profile sinks
pwsw validate            # Check config without starting daemon
```

## Common Gotchas

1. **Wayland thread panics**: The Wayland event loop runs in a separate thread. If it panics, the mpsc channel closes and daemon shuts down. However, the event loop properly detects channel closure and shuts down gracefully. Check thread spawn in compositor/mod.rs.

2. **Stale sockets**: If daemon crashes, the Unix socket may remain. Next daemon start auto-cleans stale sockets (500ms timeout health check). Socket permissions are enforced (0o600) on creation.

3. **Profile switch timing**: Some audio devices take >150ms to create new sink nodes after profile switch. If switches fail, increase PROFILE_SWITCH_DELAY_MS or PROFILE_SWITCH_MAX_RETRIES in pipewire.rs. Note: Concurrent profile switches on the same device are not supported.

4. **Regex validation**: Config validation compiles all regexes at load time. If a rule has invalid regex, daemon won't start. Be aware of catastrophic backtracking with complex patterns.

5. **Default sink requirement**: Config must have exactly one sink with `default = true`. Daemon will fail to start otherwise. This is enforced at config validation time.

6. **No GNOME support**: GNOME/Mutter doesn't expose window management protocols. This is a compositor limitation, not a code issue.

7. **Protocol version compatibility**: The code validates Wayland protocol versions (wlr: 1-3, plasma: 1-16). If a compositor advertises an incompatible version, binding will fail with a clear error.

8. **Health check timeout**: IPC health checks use a 500ms timeout to accommodate slow systems and high load scenarios. This prevents false negatives during daemon startup.

## Known Issues & Limitations

### KDE Plasma Support (Experimental)
The plasma-window-management protocol implementation has known issues:
- **Window ID mismatch**: May not correctly track windows on KDE Plasma/KWin
- **Untested**: Code has not been verified on actual Plasma systems
- See src/compositor/plasma.rs for detailed documentation

### Memory Usage
- `all_windows` HashMap duplicates some data from `active_windows` (intentional for `test-rule` command)
- IPC handlers clone config and window data on each request (not critical for single-user daemon)

### Security Notes
- Socket permissions (0o600) prevent unauthorized access on multi-user systems
- All external commands (pw-dump, pw-cli, pw-metadata) use proper JSON serialization
- No authentication beyond filesystem permissions (Unix socket is local-only)
- Complex regex patterns in rules could cause performance issues (catastrophic backtracking)

## Code Location Quick Reference

- CLI parsing: `src/cli.rs`
- CLI command implementations: `src/commands.rs`
- Daemon entry point: `src/bin/pwsw.rs`
- State machine: `src/state.rs`
- Wayland integration: `src/compositor/mod.rs`, `src/compositor/wlr_toplevel.rs`, `src/compositor/plasma.rs`
- PipeWire control: `src/pipewire.rs`
- IPC protocol: `src/ipc.rs`
- Config parsing: `src/config.rs`
- Notifications: `src/notification.rs`

## Dependencies to Be Aware Of

- `wayland-client`: Handles Wayland protocol bindings (not async)
- `tokio`: Async runtime (minimal features: net, io-util, signal, sync, time)
- `regex`: Compiled once during config load, reused for all matching
- `serde_json`: Used for pw-dump parsing, IPC protocol, and secure command construction
- `notify-rust`: Desktop notifications (may fail silently if no daemon)
- `anyhow`: Error handling with context chaining (prefer over custom error types)
- External tools: `pw-dump`, `pw-metadata`, `pw-cli` (must be in PATH)

## Development Workflow

### Before Committing
1. **Format code**: `cargo fmt`
2. **Check clippy**: `cargo clippy --all-targets` (should pass with 7 acceptable warnings)
3. **Run pedantic check**: `cargo clippy --all-targets -- -W clippy::pedantic`
4. **Validate**: `cargo run -- validate` (checks config parsing)
5. **Test manually**: Start daemon and verify affected functionality

### Code Review Checklist
When reviewing changes or adding features:
- [ ] All functions have proper documentation with `# Errors` and `# Panics` sections
- [ ] Technical terms use backticks in documentation
- [ ] No new clippy warnings introduced (beyond the 7 acceptable ones)
- [ ] Security: Proper JSON serialization for external commands
- [ ] Security: File/socket permissions set explicitly
- [ ] Error handling: Proper `Result` propagation with context
- [ ] Efficiency: Modern Rust patterns (map_or, clone_from, etc.)
- [ ] No `expect()` calls in production code paths (only defensive checks)

### Git Commit Messages
Use conventional commits format:
```
<type>: <subject>

<body>

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

Types: `feat`, `fix`, `refactor`, `docs`, `chore`, `test`, `perf`

### Testing Approach
While there are no automated tests yet, manual testing should cover:
1. **Window matching**: Test regex patterns with `pwsw test-rule`
2. **Sink switching**: Verify correct sink activation with `pwsw status`
3. **IPC protocol**: Test all CLI commands while daemon is running
4. **Error conditions**: Test with missing tools, invalid config, etc.
5. **Resource cleanup**: Verify socket cleanup on daemon shutdown

Future priority: Add unit tests for core logic (state management, rule matching, config validation).
