# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Refactoring Protocol & Active Work

**Active Refactoring Plan:**
We are currently executing a comprehensive refactoring plan detailed in `refactor_review_final.md`.
- **Read First:** Before performing any task, read `refactor_review_final.md` to understand the current phase and objectives.
- **Update Constantly:** After completing a step, mark it as checked `[x]` in `refactor_review_final.md`. If you change the approach, update the plan text.
- **Goal:** Modernize the codebase using ecosystem crates (`tui-input`, `notify`, `color-eyre`) to reduce boilerplate and fragility while preserving safety and testability.

**Workflow & Coordination:**
- Read `refactor_review_final.md` before starting any task
- Follow the verification cycle described below before committing
- Make small, reversible commits - prefer many tiny commits to one large one
- DO NOT push to remote without explicit user approval

## Project Overview

PWSW (PipeWire Switcher) is a Rust daemon that automatically switches PipeWire audio sinks based on active windows in Wayland compositors. It uses the wlr-foreign-toplevel-management protocol to monitor window events and PipeWire native tools (pw-dump, pw-metadata, pw-cli) for audio control.

**Key Features:**
- Automatic audio sink switching based on active window rules
- Interactive TUI for configuration and monitoring (implemented with `ratatui`)
- IPC-based CLI for daemon control
- Config file hot-reload with `notify` crate
- Comprehensive test suite (74 tests) with strict isolation

**Safety & Provenance Note:**
This codebase was entirely generated by LLMs without peer review from experienced Rust developers. However, it has undergone extensive refactoring:
- Comprehensive code review and pedantic clippy cleanup (154 warnings ‚Üí near zero)
- Test isolation improvements (no tests touch real user config)
- Async/blocking architecture improvements (spawn_blocking for PipeWire calls)
- TUI API surface narrowing and safety improvements

Exercise caution when making changes and validate thoroughly using the verification cycle below.

## Common Anti-Patterns to Avoid

**Learn from past mistakes - these patterns have caused issues in this codebase:**

### ‚ùå Anti-Pattern: Blocking PipeWire calls in async context
**Problem:** Blocks the tokio runtime, prevents concurrent event handling
```rust
// ‚ùå BAD: Blocking call in async context
pub async fn process_event(&mut self, event: WindowEvent) -> Result<()> {
    pipewire.activate_sink(&sink_name)?; // Blocks entire runtime!
}
```
**‚úÖ Solution:** Use `spawn_blocking` for all blocking operations
```rust
// ‚úÖ GOOD: Blocking work isolated
pub async fn process_event(&mut self, event: WindowEvent) -> Result<()> {
    let sink_name = sink_name.clone();
    tokio::task::spawn_blocking(move || {
        pipewire.activate_sink(&sink_name)
    }).await??;
}
```

### ‚ùå Anti-Pattern: Making struct fields private without considering render-path borrows
**Problem:** Causes borrow-checker conflicts when render code needs immutable + mutable borrows
```rust
// ‚ùå BAD: Making this private breaks render code
struct App {
    throbber_state: ThrobberState, // Made private
    config: Config,                 // Needed immutably during render
}

fn render(app: &mut App) {
    let rules = &app.config.rules;           // Immutable borrow
    render_rules(rules, &mut app.throbber);  // ERROR: can't borrow mutably
}
```
**‚úÖ Solution:** Use snapshot pattern - clone/copy small data before mutable borrows
```rust
// ‚úÖ GOOD: Snapshot read-only data first
fn render(app: &mut App) {
    // Snapshot needed data (small clones/copies)
    let rule_count = app.config.rules.len();
    let daemon_running = app.daemon_running;
    // Immutable borrow ends here

    // Now safe to take mutable borrow
    let throbber = app.throbber_state_mut();
    render_rules(rule_count, daemon_running, throbber);
}
```

### ‚ùå Anti-Pattern: Only checking `Err` from Command::spawn
**Problem:** Command may spawn successfully but fail with non-zero exit code
```rust
// ‚ùå BAD: Only checks spawn errors, not exit status
Command::new("pw-dump").output()?; // Succeeds even if pw-dump returns error!
```
**‚úÖ Solution:** Check `.status()?.success()` or `.output()` and validate exit code
```rust
// ‚úÖ GOOD: Validates exit status
let output = Command::new("pw-dump").output()?;
if !output.status.success() {
    bail!("pw-dump failed with status {}", output.status);
}
```

### ‚ùå Anti-Pattern: Deleting files without ownership/type verification
**Problem:** Security risk - could delete files not owned by daemon
```rust
// ‚ùå BAD: Deletes socket without verification
if socket_path.exists() {
    fs::remove_file(&socket_path)?; // Could delete wrong file!
}
```
**‚úÖ Solution:** Verify file type and ownership before deletion
```rust
// ‚úÖ GOOD: Validates before deletion
use std::os::unix::fs::MetadataExt;
use users::get_current_uid;

if socket_path.exists() {
    let meta = fs::metadata(&socket_path)?;
    if meta.file_type().is_socket() && meta.uid() == get_current_uid() {
        fs::remove_file(&socket_path)?;
    } else {
        warn!("Refusing to delete socket: ownership/type mismatch");
    }
}
```

### ‚ùå Anti-Pattern: Non-atomic config file writes
**Problem:** Power loss or crash can corrupt config file
```rust
// ‚ùå BAD: Direct write (not atomic)
fs::write(config_path, toml_string)?;
```
**‚úÖ Solution:** Write to temp file, set permissions, then atomic rename
```rust
// ‚úÖ GOOD: Atomic save with correct permissions
use tempfile::NamedTempFile;
use std::os::unix::fs::PermissionsExt;

let dir = config_path.parent().context("No parent dir")?;
let mut temp = NamedTempFile::new_in(dir)?;
temp.write_all(toml_string.as_bytes())?;
temp.as_file().sync_all()?;

#[cfg(unix)]
fs::set_permissions(temp.path(), fs::Permissions::from_mode(0o600))?;

temp.persist(config_path)?; // Atomic rename
```

### ‚ùå Anti-Pattern: Exposing mutable internal state unnecessarily
**Problem:** Breaks encapsulation, makes refactoring harder
```rust
// ‚ùå BAD: Public mutable field
pub struct App {
    pub status_message: Option<String>, // Direct mutation everywhere
}
```
**‚úÖ Solution:** Provide minimal accessors, keep fields private
```rust
// ‚úÖ GOOD: Private field with controlled access
pub struct App {
    status_message: Option<String>, // Private
}

impl App {
    pub fn status_message(&self) -> Option<&str> {
        self.status_message.as_deref()
    }

    pub fn set_status(&mut self, msg: impl Into<String>) {
        self.status_message = Some(msg.into());
    }
}
```

## Code Quality Standards

**All new code must adhere to these standards:**

### Clippy Compliance

Run both standard and pedantic clippy before committing:
```bash
# Standard clippy (must pass with zero warnings)
cargo clippy --all-targets

# Pedantic mode (current state: 0 warnings)
cargo clippy --all-targets -- -W clippy::pedantic
```

**Current Acceptable Pedantic Allows (16 total, as of Phase C.1.7):**

These `#[allow(clippy::...)]` annotations are justified and documented in code:
- `struct_excessive_bools` (3√ó) ‚Üí Config `Settings`, `SettingsFile`, and TUI `App` have independent boolean flags for different features (not state machines)
- `too_many_lines` (13√ó) ‚Üí Daemon event loop, TUI screens, input handlers, commands - cohesive logic hard to split meaningfully
- `items_after_statements` (2√ó) ‚Üí Constants scoped in spawn blocks for clarity
- `needless_pass_by_value` (1√ó) ‚Üí Wayland `Connection` must be moved, not borrowed (protocol requirement)
- `cast_possible_truncation` (1√ó) ‚Üí IPC message length cast validated safe (MAX_MESSAGE_SIZE within u32 range)
- `match_same_arms` (1√ó) ‚Üí Rule editor input - conceptually different field types despite similar-looking actions
- `needless_raw_string_hashes` (1√ó) ‚Üí Generated by build.rs (built_info crate)
- `doc_markdown` (1√ó) ‚Üí Generated by build.rs (built_info crate)

**Recently Fixed (demonstrating thoughtful code quality decisions):**
- `too_many_arguments` ‚Üí Fixed by bundling parameters into `RulesRenderContext` struct
- `if_not_else` ‚Üí Fixed by swapping branches (simple case first, complex logic in else)

**Policy:** Prefer fixing warnings over adding new `#[allow(...)]` attributes. Each `#[allow]` must have a comment explaining why it's necessary. When a warning can be reasonably fixed through refactoring, fix it rather than suppress it.

### Documentation Requirements

Every public function returning `Result` must have:
```rust
/// Brief description of what the function does
///
/// # Errors
/// Clear description of when/why this returns an error
pub fn example() -> Result<()> { ... }
```

Functions that may panic (using `expect()` or similar) must document:
```rust
/// # Panics
/// Description of panic conditions (even if "should never happen")
```

Technical terms must use backticks in documentation and code comments:
- ‚úÖ `PipeWire`, `app_id`, `IPC`, `XDG_RUNTIME_DIR`, `pw-dump`, `crossterm`, `ratatui`
- ‚ùå PipeWire, app_id, IPC, XDG_RUNTIME_DIR, pw-dump, crossterm, ratatui
- This includes: protocol names, command-line tools, environment variables, technical identifiers, and library names

### Code Quality Patterns

**Error Handling:**
- Use `anyhow::Result` and `Context` for rich error propagation in application code
- Avoid `.expect()` in production paths (only for defensive checks that should never fail)
- Document all panic conditions with `# Panics`
- Check process exit codes with `.status()?.success()`, not just spawn errors

**Efficiency:**
- Prefer `clone_from()` over reassignment: `string.clone_from(&other)` instead of `string = other.clone()`
- Use `map_or()` / `map_or_else()` instead of `map().unwrap_or()`
- Use `is_some_and()` instead of `map().unwrap_or(false)`
- Dereference before `to_string()`: `(*str_ref).to_string()` instead of `str_ref.to_string()`

**Modern Patterns:**
- Use `let-else` for early returns: `let Ok(value) = result else { return false };`
- Derive `Copy` for simple enums when possible
- Use `#[must_use]` on functions that return important values (but document why with `# Panics` if caller ignores)

**Borrow-Checker Snapshot Pattern:**
When you need both immutable and mutable borrows in render/update paths:
1. Snapshot read-only data first (clone/copy small values into local variables)
2. Let immutable borrows go out of scope
3. Then take mutable borrows
4. Prefer this over adding `RefCell`/`Mutex` just to bypass borrow checker

### Performance Patterns: Async vs Blocking Decision Tree

**When to use `spawn_blocking`:**
- All PipeWire operations (`pw-dump`, `pw-cli`, `pw-metadata`)
- File I/O operations (reading/writing config, large files)
- Regex compilation (if done at runtime)
- Any operation that might take >100ms

**When to use regular async:**
- IPC request/response handling
- Event processing in daemon loop
- State updates (in-memory operations)
- Wayland protocol events (already in separate thread)

**Example pattern:**
```rust
pub async fn activate_sink(&self, sink_name: &str) -> Result<()> {
    let sink = sink_name.to_string();
    tokio::task::spawn_blocking(move || {
        // Blocking PipeWire work here
        Self::activate_sink_blocking(&sink)
    }).await?
}
```

### Security Practices

**Command Execution:**
- Always use proper JSON serialization (`serde_json::json!`) instead of string formatting
- Never construct shell commands with user input
- Validate all external command outputs
- Check both spawn success AND exit status: `output.status.success()`

**IPC Security:**
- Unix sockets must have `0o600` permissions (user-only access)
- Validate message sizes before allocation
- Use length-prefixed protocol to prevent injection attacks

**File Operations:**
- Use `path.display()` instead of Debug formatting (`{:?}`) in user-facing messages
- Set explicit permissions on created files/sockets: `fs::Permissions::from_mode(0o600)`
- Verify ownership before deleting: `metadata.uid() == users::get_current_uid()`
- Verify file type before operations: `metadata.file_type().is_socket()`
- Clean up stale files before binding sockets
- Use atomic writes (temp file + rename) for important files like configs

**Atomic File Writes Pattern:**
```rust
use tempfile::NamedTempFile;
use std::os::unix::fs::PermissionsExt;

let dir = path.parent().context("No parent directory")?;
let mut temp = NamedTempFile::new_in(dir)?;
temp.write_all(content.as_bytes())?;
temp.as_file().sync_all()?;

#[cfg(unix)]
fs::set_permissions(temp.path(), fs::Permissions::from_mode(0o600))?;

temp.persist(path)?; // Atomic rename on POSIX
```

### Terminal Styling

All CLI commands use semantic styling via `crossterm` for consistent, readable output:

**Style Module (`src/style.rs`):**
- Single-trait extension (`PwswStyle`) that adds semantic methods to `crossterm::style::Stylize`
- All styling must go through this trait (never use raw ANSI codes or direct `crossterm` colors)
- Pattern: Import both `crossterm::style::Stylize` and `crate::style::PwswStyle` in files that need styling

**Color Scheme ("Moderate+" approach):**
- `.header()` - Cyan bold for section headers (e.g., "ACTIVE SINKS:", "Daemon")
- `.success()` - Green for positive states (e.g., "Running", "active", success messages)
- `.error()` - Red for problems (e.g., "Not running", "not found", error messages)
- `.warning()` - Yellow for warnings or partial states (e.g., "profile switch", warnings)
- `.technical()` - Cyan for technical content (e.g., regex patterns, counts, paths)
- `.bold()` - Direct from `Stylize` for important identifiers (e.g., node names, descriptions)
- `.dim()` - Direct from `Stylize` for secondary information (e.g., labels, markers)

**Ownership Note:**
- Style methods consume their receiver (take ownership)
- For borrowed values like `&String`, use `.as_str()` before styling: `sink.name.as_str().bold()`
- For owned values or `&str`, call directly: `"Header".header()`

**Usage:** Terminal styling is used by both CLI commands and the TUI (via shared `crossterm` dependency).

## Testing Standards

### Test Isolation (CRITICAL)

**Tests MUST NOT touch real user config (`~/.config/pwsw/config.toml`)**

All tests must use isolated temporary XDG directories:

```rust
use crate::test_utils::XdgTemp;

#[test]
fn test_config_save() {
    let _xdg = XdgTemp::new(); // Creates isolated XDG_CONFIG_HOME
    // Test code here - safe to read/write config
} // XdgTemp drops and cleans up temp directory
```

**Verification:**
```bash
# MUST pass before committing
bash scripts/verify_tests_safe.sh
```

This script ensures:
- No test reads from real `~/.config/pwsw`
- No test writes to real config paths
- All config operations use `XdgTemp` or explicit temp paths

**Test Requirements:**
- Unit tests must be fast and deterministic (no sleep, no external dependencies)
- Tests that need config must use `XdgTemp` pattern
- Mock or stub external commands (pw-dump, pw-cli) where possible
- Use `#[cfg(test)]` modules for test-only helpers
- Add `#[tokio::test]` for async test functions

### Test Coverage (Current: 74 tests)

Test coverage by module:
- `config.rs`: 15 tests - Config validation, sink resolution, default sink handling
- `state.rs`: 12 tests - Rule matching, priority logic, window tracking
- `pipewire.rs`: 12 tests - JSON parsing from `pw-dump` output (no external dependencies)
- `ipc.rs`: 8 tests - Request/Response serialization roundtrips
- `notification.rs`: 6 tests - Icon auto-detection for sinks and apps
- `style.rs`: 1 doctest - Styling trait usage example
- TUI modules: Additional tests for input handling, widgets, and state management

All tests are inline `#[cfg(test)]` modules that test pure functions without external dependencies (no PipeWire/Wayland calls).

## Repository Scripts

### Verification & Automation Scripts

**`scripts/verify_tests_safe.sh`** (Critical - run before every commit)
- Validates that tests don't modify real user config
- Checks for hardcoded paths to `~/.config/pwsw`
- Ensures `XdgTemp` pattern is used correctly
- Returns non-zero exit code if unsafe patterns detected

**`scripts/install_git_hook.sh`**
- Sets up pre-commit hooks for automatic validation
- Runs formatting, tests, and safety checks before allowing commit
- Recommended for all contributors

**Usage:**
```bash
# One-time setup
bash scripts/install_git_hook.sh

# Manual verification (run before commits if hooks not installed)
bash scripts/verify_tests_safe.sh
```

## Build Commands

### Development
```bash
# Build in debug mode
cargo build

# Build with optimizations
cargo build --release

# Check without building
cargo check

# Run tests (with safety verification)
cargo test && bash scripts/verify_tests_safe.sh

# Run clippy for linting
cargo clippy --all-targets
cargo clippy --all-targets -- -W clippy::pedantic

# Format code
cargo fmt
```

### Installation
```bash
# Install to ~/.cargo/bin/
cargo install --path .

# The binary will be at:
# - Debug: target/debug/pwsw
# - Release: target/release/pwsw
```

### Running
```bash
# Start daemon in foreground (for debugging)
cargo run -- daemon --foreground

# Start daemon in background
cargo run -- daemon

# CLI commands (require running daemon for IPC commands)
cargo run -- status
cargo run -- list-sinks
cargo run -- list-windows
cargo run -- test-rule "^firefox$"
cargo run -- validate

# TUI mode (interactive interface)
cargo run -- tui
```

## Architecture

### Core Components

**Daemon Mode (`daemon.rs`)**
- Main event loop using `tokio::select!` to multiplex:
  - Compositor window events (via mpsc channel from Wayland thread)
  - IPC requests from CLI clients (via Unix socket)
  - Config file watch events (via `notify` crate)
  - Shutdown signals (Ctrl-C or IPC shutdown request)
- Owns the State and manages the lifecycle
- All blocking operations (PipeWire calls) use `spawn_blocking`

**State Management (`state.rs`)**
- Tracks active windows that matched rules (HashMap<u64, ActiveWindow>)
- Implements rule matching logic (app_id + optional title regex)
- Priority system: most recently opened matching window wins
- When windows close or stop matching, determines target sink from remaining active windows
- Falls back to default sink when no rules match
- `process_event()` is async and uses `spawn_blocking` for sink activation

**IPC Infrastructure (`ipc.rs`)**
- Unix socket-based client-server communication
- Length-prefixed JSON protocol (4-byte big-endian length + JSON payload)
- Socket location: `$XDG_RUNTIME_DIR/pwsw.sock` or `/tmp/pwsw-$USER.sock`
- Socket permissions: `0o600` (user-only access for security)
- Automatic stale socket cleanup on daemon start with ownership verification
- Request types: Status, Reload, ListWindows, TestRule, Shutdown
- Response types: Status, Ok, Error, Windows, RuleMatches
- Window identity uses unique IDs (not app_id/title pairs) for correctness

**Compositor Abstraction (`compositor/mod.rs`)**
- Protocol detection via Wayland registry scan
- Spawns dedicated `std::thread` for Wayland event loop (Wayland is not async-friendly)
- Sends WindowEvent enum (Opened, Changed, Closed) to tokio runtime via unbounded mpsc channel
- Implementation: `wlr_toplevel.rs` for wlr-foreign-toplevel-management protocol (Sway, Hyprland, Niri, River, etc.)
- Graceful shutdown on channel closure

**PipeWire Integration (`pipewire.rs`)**
- Parses `pw-dump` JSON output for sinks, devices, profiles, and metadata
- Active sinks: Audio/Sink nodes currently available
- Profile sinks: Predicted node names for sinks that require profile switching
- Profile switching workflow:
  1. Acquire per-device lock to serialize switches on same device
  2. Call `pw-cli` to switch device profile (uses proper JSON serialization)
  3. Wait with retries (150ms √ó 5 max) for new sink node to appear
  4. Set as default with `pw-metadata`
- Node name prediction: `alsa_output.{device_suffix}.{profile_suffix}`
- **Concurrency:** Profile switching uses per-device `std::sync::Mutex` to prevent concurrent switches on same device
- **Performance:** All operations use `spawn_blocking` to avoid blocking tokio runtime

**Configuration (`config.rs`)**
- TOML format at `$XDG_CONFIG_HOME/pwsw/config.toml`
- Validation rules:
  - Exactly one default sink required
  - No duplicate sink names or descriptions
  - All rule sink references must resolve (by position, desc, or name)
  - Log level must be valid
- Creates default config if none exists
- Sink references support: 1-indexed position, description, or node name
- **Atomic saves:** Write to temp file ‚Üí set 0o600 permissions ‚Üí atomic rename
- **Hot-reload:** Daemon watches config file with `notify` crate, validates on change

**TUI Mode (`src/tui/`)**
- Interactive terminal UI built with `ratatui` and `crossterm`
- Features:
  - Real-time sink and window monitoring
  - Rule editing with live preview
  - Config editing with validation
  - Daemon status and control
  - Integrated help system
- Components:
  - `app.rs` - Main application state and event handling
  - `mod.rs` - Event loop and rendering coordination
  - `input.rs` - Text input widget using `tui-input` crate
  - `screens/` - Individual screen implementations (rules, sinks, settings, help)
  - `widgets.rs` - Shared UI components (scroll arrows, sink selectors)
  - `preview.rs` - Rule matching preview logic
- **Architecture:** Uses snapshot pattern to avoid borrow-checker conflicts (see Anti-Patterns section)
- **Logging:** Integrated with `tui-logger` for in-TUI log viewing
- **Error Handling:** Uses `color-eyre` for rich error reports with backtraces

**Notifications (`notification.rs`)**
- Desktop notifications using `notify-rust`
- Icon auto-detection from sink/app descriptions
- May fail silently if no notification daemon available
- Used for manual switches and rule-based switches (configurable)

### Data Flow

1. **Window Event Flow**:
   - Wayland compositor emits protocol events
   - Compositor thread receives and converts to WindowEvent
   - Sent via mpsc channel to daemon's tokio runtime
   - State processes event (async) and determines if sink switch is needed
   - `PipeWire::activate_sink()` called via `spawn_blocking` if switch required

2. **IPC Request Flow**:
   - CLI client connects to Unix socket
   - Sends length-prefixed JSON request
   - Daemon spawns tokio task to handle request
   - Task reads current state snapshot (no shared mutable state)
   - Response written back to same socket
   - Window info includes unique IDs for accurate tracking

3. **Profile Switching Flow**:
   - Check if sink is active (quick path: just set default)
   - If not active, check profile_sinks for predicted name
   - Acquire device-specific lock (serialize switches per device)
   - Switch device profile with `pw-cli`
   - Poll with retries for new sink node to appear
   - Set as default with `pw-metadata`
   - Release lock

4. **Config Hot-Reload Flow**:
   - `notify` crate watches config directory
   - Filter events to only actual config file changes
   - Debounce rapid events via `try_send` (avoid blocking watcher)
   - Validate new config before signaling daemon
   - Daemon reloads config but does not auto-restart (requires manual restart for changes to take effect)

### Threading Model

- **Main Tokio Runtime**: Runs daemon event loop, IPC server, signal handlers, config watcher
- **Wayland Thread**: Dedicated `std::thread` for Wayland event loop (blocking, not async)
- **IPC Handler Tasks**: Spawned tokio tasks for each IPC connection (non-blocking)
- **Blocking Workers**: `spawn_blocking` tasks for PipeWire operations (pool managed by tokio)

State is owned by the main loop. IPC handlers clone only what they need (uptime, current_sink_name, tracked windows list) to avoid shared mutable state. Per-device profile locks use `std::sync::Mutex` (safe in `spawn_blocking`).

### Key Design Patterns

**Priority-based sink switching**: Most recent matching window wins. When it closes, next most recent takes over.

**Predicted node names**: Profile sinks use string manipulation to predict the node name before switching (enables config validation).

**Protocol abstraction**: WindowEvent enum allows adding new compositor protocols without changing daemon logic.

**No config hot-reload restart**: Reload command validates config but requires daemon restart for changes to take effect. This avoids complex state synchronization.

**Snapshot pattern for renders**: TUI render code snapshots read-only data before taking mutable borrows to avoid borrow-checker conflicts (see Anti-Patterns section).

**Async + blocking hybrid**: Async event loop with `spawn_blocking` for PipeWire calls to avoid blocking runtime.

## Configuration Notes

### Finding Window App IDs and Titles

Different compositors provide different tools:
- Sway/River/wlroots: `swaymsg -t get_tree`
- Hyprland: `hyprctl clients`
- Niri: `niri msg windows`
- KDE Plasma: KDE's window inspector
- Or use: `pwsw list-windows` (while daemon is running)
- TUI: `pwsw tui` ‚Üí Windows tab shows all tracked windows

### Regex Pattern Syntax

Window rules support full Rust regex syntax:
- `"firefox"` - matches anywhere in string
- `"^steam$"` - exact match only
- `"^(mpv|vlc)$"` - matches mpv OR vlc
- `"(?i)discord"` - case insensitive

Both app_id and title support regex. If title is omitted, any title matches.

**Pattern Testing:**
```bash
# CLI testing
pwsw test-rule "^firefox$"
pwsw test-rule "^.*Discord.*$"

# TUI testing
pwsw tui  # Rules tab has live preview of matches
```

### Sink Icon Auto-detection

Icons are auto-detected from sink descriptions:
- "HDMI" ‚Üí video-display
- "headphone" ‚Üí audio-headphones
- "speaker" ‚Üí audio-speakers
- "analog" ‚Üí audio-card
- Override with explicit `icon = "..."` in config

## Testing

### Manual Testing Workflow

When making changes to window matching or state management logic, test with:
```bash
# Start daemon in foreground to see logs
pwsw daemon --foreground

# In another terminal:
pwsw list-windows        # See what windows daemon knows about
pwsw test-rule "^mpv$"   # Test regex patterns
pwsw status              # Check current state

# Or use the TUI
pwsw tui                 # Interactive interface with live updates
```

For PipeWire integration changes:
```bash
pwsw list-sinks          # See active and profile sinks
pwsw validate            # Check config without starting daemon
```

### Automated Testing

Run the full test suite with safety verification:
```bash
# Run all tests
cargo test

# Verify tests don't touch real config (CRITICAL)
bash scripts/verify_tests_safe.sh

# Check for clippy issues
cargo clippy --all-targets
cargo clippy --all-targets -- -W clippy::pedantic
```

## Common Gotchas

1. **Wayland thread panics**: The Wayland event loop runs in a separate thread. If it panics, the mpsc channel closes and daemon shuts down gracefully. The event loop properly detects channel closure. Check thread spawn in `compositor/mod.rs`.

2. **Stale sockets**: If daemon crashes, the Unix socket may remain. Next daemon start auto-cleans stale sockets with ownership/type verification (500ms timeout health check). Socket permissions are enforced (`0o600`) on creation.

3. **Profile switch timing**: Some audio devices take >150ms to create new sink nodes after profile switch. If switches fail, increase `PROFILE_SWITCH_DELAY_MS` or `PROFILE_SWITCH_MAX_RETRIES` in `pipewire.rs`. Note: Per-device locks prevent concurrent profile switches on same device.

4. **Regex validation**: Config validation compiles all regexes at load time. If a rule has invalid regex, daemon won't start. Be aware of catastrophic backtracking with complex patterns. Test patterns with `pwsw test-rule` before adding to config.

5. **Default sink requirement**: Config must have exactly one sink with `default = true`. Daemon will fail to start otherwise. This is enforced at config validation time.

6. **Unsupported compositors**:
   - GNOME/Mutter doesn't expose window management protocols
   - KDE Plasma 6 removed the plasma-window-management protocol and hasn't implemented a replacement yet
   - These are compositor limitations, not code issues

7. **Protocol version compatibility**: The code validates Wayland protocol versions (wlr: 1-3). If a compositor advertises an incompatible version, binding will fail with a clear error.

8. **Health check timeout**: IPC health checks use a 500ms timeout to accommodate slow systems and high load scenarios. This prevents false negatives during daemon startup.

9. **Test isolation**: Always use `XdgTemp` in tests that touch config. Running tests without this will fail safety verification (`scripts/verify_tests_safe.sh`).

10. **Blocking calls in async**: Never call `pw-dump`, `pw-cli`, or other blocking commands directly in async functions. Always use `spawn_blocking`. See Anti-Patterns section above.

## Known Issues & Limitations

### Memory Usage
- `all_windows` HashMap duplicates some data from `active_windows` (intentional for `test-rule` command and TUI display)
- IPC handlers clone config and window data on each request (not critical for single-user daemon)
- TUI maintains additional state for rendering (config snapshots, cached regex compilations)

### Security Notes
- Socket permissions (`0o600`) prevent unauthorized access on multi-user systems
- All external commands (`pw-dump`, `pw-cli`, `pw-metadata`) use proper JSON serialization
- No authentication beyond filesystem permissions (Unix socket is local-only)
- Complex regex patterns in rules could cause performance issues (catastrophic backtracking)
- Stale socket cleanup verifies ownership and file type before deletion

### Compositor Protocol Support

**Current Status:**
- **Supported:** `zwlr_foreign_toplevel_manager_v1` (wlroots/Smithay compositors)
- **Not Supported:** GNOME/Mutter, KDE Plasma 6

**Protocol History:**

*KDE Plasma Support (Removed December 2024):*
- Plasma 5 supported `org_kde_plasma_window_management` protocol
- Initial implementation added in v0.2.0 but marked experimental/untested
- Plasma 6 (released February 2024) removed this protocol entirely
- Support was dropped after confirming Plasma 6 has no window management protocol
- Removed files: `src/compositor/plasma.rs`, `wayland-protocols-plasma` dependency

**Future Protocol Opportunities:**

*ext-foreign-toplevel-list v1:*
- Part of official wayland-protocols (staging state)
- Intended as standardized replacement for wlr-foreign-toplevel-management
- **Key difference:** Read-only list of toplevels (no window control capabilities)
- **For pwsw:** This limitation is acceptable - we only need to monitor windows, not control them
- **Current adoption:** Minimal (as of December 2024)
- **Potential benefit:** Could enable support for KDE Plasma 6 and other compositors if/when they implement it

*Implementation considerations for ext-foreign-toplevel-list:*
1. Add dependency: `wayland-protocols` with `staging` feature enabled
2. Create new implementation: `src/compositor/ext_toplevel.rs`
3. Update protocol detection priority: wlr ‚Üí ext ‚Üí (future protocols)
4. Similar event model to wlr implementation (Opened, Changed, Closed events)
5. May need to handle different window identification schemes

**Resources:**
- wayland-protocols repository: https://gitlab.freedesktop.org/wayland/wayland-protocols
- ext-foreign-toplevel spec: `staging/ext-foreign-toplevel-list/`
- KDE Plasma 6 protocol status: Monitor KWin releases for protocol additions

**Decision rationale:**
- Hold implementation until ext-foreign-toplevel moves from staging to stable
- Ensures protocol stability and wider compositor adoption before investing effort
- Current wlr-based implementation covers majority of Wayland compositors in active use

## Code Location Quick Reference

**Core Daemon:**
- CLI parsing: `src/cli.rs`
- CLI command implementations: `src/commands.rs`
- Daemon entry point: `src/bin/pwsw.rs`
- Main daemon loop: `src/daemon.rs`
- State machine: `src/state.rs`

**Integration:**
- Wayland integration: `src/compositor/mod.rs`, `src/compositor/wlr_toplevel.rs`
- PipeWire control: `src/pipewire.rs`
- IPC protocol: `src/ipc.rs`
- Config parsing: `src/config.rs`
- Notifications: `src/notification.rs`

**TUI:**
- Main TUI app: `src/tui/app.rs`
- Event loop & rendering: `src/tui/mod.rs`
- Text input widget: `src/tui/input.rs`
- Rule matching preview: `src/tui/preview.rs`
- Shared widgets: `src/tui/widgets.rs`
- Screens: `src/tui/screens/` (rules, sinks, settings, help)

**Utilities:**
- Terminal styling: `src/style.rs`
- Test helpers: `src/test_utils.rs`

## Dependencies to Be Aware Of

### Core Functionality
- `wayland-client`: Handles Wayland protocol bindings (not async)
- `tokio`: Async runtime (minimal features: rt-multi-thread, net, io-util, signal, sync, time)
- `regex`: Compiled once during config load, reused for all matching
- `serde_json`: Used for pw-dump parsing, IPC protocol, and secure command construction
- `anyhow`: Error handling with context chaining (prefer over custom error types)
- `toml` / `serde`: Config file parsing and serialization

### External Tools (must be in PATH)
- `pw-dump` - PipeWire state introspection
- `pw-metadata` - Set default sink
- `pw-cli` - Device profile switching

### TUI & User Interface
- `ratatui`: Terminal UI framework (crossterm backend)
- `crossterm`: Terminal manipulation and styling (used by CLI and TUI)
- `tui-input`: Text input widget with cursor support
- `tui-logger`: Integrated log viewer for TUI
- `throbber-widgets-tui`: Loading spinners for async operations
- `color-eyre`: Enhanced error reports with backtraces and color
- `notify-rust`: Desktop notifications (may fail silently if no daemon)

### File & System Operations
- `notify`: File system watching for config hot-reload
- `tempfile`: Safe temporary file creation for atomic writes
- `users`: UID lookup for ownership verification
- `dirs`: XDG directory standard support

### Utilities
- `tracing` / `tracing-subscriber`: Structured logging
- `clap`: CLI argument parsing (derive API)
- `futures-util`: Async stream utilities

## Development Workflow

### Verification Cycle (Run Before EVERY Commit)

```bash
# 1. Format code
cargo fmt

# 2. Run tests
cargo test

# 3. Verify test safety (CRITICAL - must pass)
bash scripts/verify_tests_safe.sh

# 4. Check standard clippy
cargo clippy --all-targets

# 5. Check pedantic clippy
cargo clippy --all-targets -- -W clippy::pedantic

# 6. Manual testing (if relevant)
cargo run -- daemon --foreground  # Start daemon
cargo run -- status                # Test CLI
cargo run -- tui                   # Test TUI
```

**Automate with git hooks:**
```bash
bash scripts/install_git_hook.sh
```

### Code Review Checklist

When reviewing changes or adding features:
- [ ] All functions have proper documentation with `# Errors` and `# Panics` sections
- [ ] Technical terms use backticks in documentation
- [ ] No new clippy warnings introduced (standard or pedantic)
- [ ] Security: Proper JSON serialization for external commands
- [ ] Security: File/socket permissions set explicitly (`0o600`)
- [ ] Security: Ownership verification before file deletion
- [ ] Error handling: Process exit codes checked with `.status()?.success()`
- [ ] Performance: Blocking operations use `spawn_blocking`
- [ ] Testing: New tests use `XdgTemp` for config isolation
- [ ] Testing: `scripts/verify_tests_safe.sh` passes
- [ ] Borrow checker: Snapshot pattern used for render paths (not `RefCell`)
- [ ] No `expect()` calls in production code paths (only defensive checks)

### Git Commit Messages

Use conventional commits format:
```
<type>: <subject>

<body>

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

**Types:** `feat`, `fix`, `refactor`, `docs`, `chore`, `test`, `perf`

**Guidelines:**
- Subject: Concise (50 chars), imperative mood ("add" not "added")
- Body: Explain WHY, not just what. Reference issues/PRs if applicable.
- Include rationale for non-obvious changes
- Link to `refactor_review_final.md` if part of refactor plan

### Git Push Policy

**Push commits to remote ONLY when explicitly approved by the user.**

**NEVER push changes to remote without explicit user approval.**

When creating commits:
1. Always create the commit locally
2. Inform the user that the commit was created but not pushed
3. Wait for explicit approval (e.g., "push it", "go ahead and push", "yes push") before running `git push`
4. If approved, push with: `git push` (or `git push -u origin <branch>` for new branches)

### Incremental Refactoring Approach

When tackling large refactors (from lessons learned in Phase C.1):

**1. Capture baseline:**
```bash
cargo clippy --all-targets -- -W clippy::pedantic > /tmp/baseline.txt
```

**2. Extract pure logic:**
- Move complex calculations/matching into testable helper functions
- Keep helpers pure (no side effects, no mutable state)
- Add unit tests for helpers

**3. Move items out of functions:**
- Hoist `use`, `const`, type aliases to module level
- Prefer module-level definitions for widely-used items

**4. Consolidate duplicates:**
- Extract duplicated widget rendering into shared helpers
- Create reusable components in `widgets.rs`

**5. Remove dead code:**
- Use `rg`/`git grep` to verify no callers before deletion
- Remove `#[allow(dead_code)]` by actually removing the code

**6. Fix remaining warnings:**
- Prefer refactors and micro-fixes over adding `#[allow(...)]`
- Document each `#[allow]` with inline comment explaining why

**7. Final cleanup:**
- Remove temporary allows where underlying cause was fixed
- Update documentation and refactor plan

**Per-step commit:** Small, reversible commits. Run verification cycle after each. Don't push until phase complete.

### Testing Approach

**Automated Tests (74 total):**
Run the test suite with:
```bash
cargo test              # Run all tests
cargo test --lib        # Run unit tests only
```

Test coverage by module:
- `config.rs`: 15 tests - Config validation, sink resolution, default sink handling
- `state.rs`: 12 tests - Rule matching, priority logic, window tracking
- `pipewire.rs`: 12 tests - JSON parsing from `pw-dump` output (no external dependencies)
- `ipc.rs`: 8 tests - Request/Response serialization roundtrips
- `notification.rs`: 6 tests - Icon auto-detection for sinks and apps
- `style.rs`: 1 doctest - Styling trait usage example
- TUI modules: Various tests for input, widgets, preview logic

All tests are inline `#[cfg(test)]` modules that test pure functions without external dependencies (no PipeWire/Wayland calls).

**Manual Testing:**
For features not covered by unit tests, manual testing should cover:
1. **Window matching**: Test regex patterns with `pwsw test-rule` or TUI Rules tab
2. **Sink switching**: Verify correct sink activation with `pwsw status` or TUI Sinks tab
3. **IPC protocol**: Test all CLI commands while daemon is running
4. **Error conditions**: Test with missing tools, invalid config, etc.
5. **Resource cleanup**: Verify socket cleanup on daemon shutdown
6. **Config hot-reload**: Edit config while daemon running, verify validation
7. **TUI functionality**: Navigate all screens, test input, verify real-time updates
