# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Active Work & Planning

**Workflow & Coordination:**
- Follow the verification cycle described below before committing
- Make small, reversible commits - prefer many tiny commits to one large one
- DO NOT push to remote without explicit user approval

**Recent Achievements:**
- **Protocol Expansion (2025-12-24)**: Implemented `ext-foreign-toplevel-list-v1` support, providing a standardized, future-proof window monitoring backend.
- **Edition 2024 Upgrade (2025-12-21)**: Rust 1.92 MSRV, Edition 2024 baseline, let_chains feature adoption (4 sites simplified)
- Lint configuration centralized: 22 pedantic suppressions moved to `[lints]` table in Cargo.toml (2 remain in generated code)
- Comprehensive refactoring completed: Modernized codebase using ecosystem crates (`tui-input`, `notify`, `color-eyre`)
- Zero pedantic clippy warnings achieved (25 suppressions centralized)
- Enhanced color system with semantic constants (magenta focus, validation feedback, accessibility features)
- TUI log highlighting and improved visual feedback

## Future Roadmap

**High Value / Low Effort:**
- **Clipboard Integration:** Add `y`/`c` shortcut in TUI to copy `app_id`/`title` (crates: `arboard` or `copypasta`).
- **Mouse Support:** Enable mouse capture in TUI for tab clicking and list scrolling (supported by `ratatui`/`crossterm`).

**Architecture Evolution:**
- **Stability Tuning:** Continue monitoring `ext-foreign-toplevel-list-v1` adoption and stability.

**Architecture Decisions:**
- **PipeWire Integration:** Deliberately chose process isolation (shelling out to `pw-dump`/`pw-cli`) over native Rust bindings. The `pipewire` crate relies on unsafe FFI, lacks native async support (requires complex thread bridging), and could crash the daemon on library errors. The current CLI approach is robust, safe, and isolates failures. Native bindings are not recommended unless the ecosystem matures significantly.

## Project Overview

PWSW (PipeWire Switcher) is a Rust daemon that automatically switches PipeWire audio sinks based on active windows in Wayland compositors. It uses the wlr-foreign-toplevel-management protocol to monitor window events and PipeWire native tools (pw-dump, pw-metadata, pw-cli) for audio control.

**Key Features:**
- Automatic audio sink switching based on active window rules
- Interactive TUI for configuration and monitoring (implemented with `ratatui`)
- IPC-based CLI for daemon control
- Config file hot-reload with `notify` crate
- Comprehensive test suite (90 tests) with strict isolation

**Safety & Provenance Note:**
This codebase was entirely generated by LLMs without peer review from experienced Rust developers. However, it has undergone extensive refactoring:
- Comprehensive code review and pedantic clippy cleanup (154 warnings → near zero)
- Test isolation improvements (no tests touch real user config)
- Async/blocking architecture improvements (spawn_blocking for PipeWire calls)
- TUI API surface narrowing and safety improvements

Exercise caution when making changes and validate thoroughly using the verification cycle below.

## Common Anti-Patterns to Avoid

**Learn from past mistakes - these patterns have caused issues in this codebase:**

### ❌ Anti-Pattern: Blocking PipeWire calls in async context
**Problem:** Blocks the tokio runtime, prevents concurrent event handling
```rust
// ❌ BAD: Blocking call in async context
pub async fn process_event(&mut self, event: WindowEvent) -> Result<()> {
    pipewire.activate_sink(&sink_name)?; // Blocks entire runtime!
}
```
**✅ Solution:** Use `spawn_blocking` for all blocking operations
```rust
// ✅ GOOD: Blocking work isolated
pub async fn process_event(&mut self, event: WindowEvent) -> Result<()> {
    let sink_name = sink_name.clone();
    tokio::task::spawn_blocking(move || {
        pipewire.activate_sink(&sink_name)
    }).await??;
}
```

### ❌ Anti-Pattern: Making struct fields private without considering render-path borrows
**Problem:** Causes borrow-checker conflicts when render code needs immutable + mutable borrows
```rust
// ❌ BAD: Making this private breaks render code
struct App {
    throbber_state: ThrobberState, // Made private
    config: Config,                 // Needed immutably during render
}

fn render(app: &mut App) {
    let rules = &app.config.rules;           // Immutable borrow
    render_rules(rules, &mut app.throbber);  // ERROR: can't borrow mutably
}
```
**✅ Solution:** Use snapshot pattern - clone/copy small data before mutable borrows
```rust
// ✅ GOOD: Snapshot read-only data first
fn render(app: &mut App) {
    // Snapshot needed data (small clones/copies)
    let rule_count = app.config.rules.len();
    let daemon_running = app.daemon_running;
    // Immutable borrow ends here

    // Now safe to take mutable borrow
    let throbber = app.throbber_state_mut();
    render_rules(rule_count, daemon_running, throbber);
}
```

### ❌ Anti-Pattern: Only checking `Err` from Command::spawn
**Problem:** Command may spawn successfully but fail with non-zero exit code
```rust
// ❌ BAD: Only checks spawn errors, not exit status
Command::new("pw-dump").output()?; // Succeeds even if pw-dump returns error!
```
**✅ Solution:** Check `.status()?.success()` or `.output()` and validate exit code
```rust
// ✅ GOOD: Validates exit status
let output = Command::new("pw-dump").output()?;
if !output.status.success() {
    bail!("pw-dump failed with status {}", output.status);
}
```

### ❌ Anti-Pattern: Deleting files without ownership/type verification
**Problem:** Security risk - could delete files not owned by daemon
```rust
// ❌ BAD: Deletes socket without verification
if socket_path.exists() {
    fs::remove_file(&socket_path)?; // Could delete wrong file!
}
```
**✅ Solution:** Verify file type and ownership before deletion
```rust
// ✅ GOOD: Validates before deletion
use std::os::unix::fs::MetadataExt;
use users::get_current_uid;

if socket_path.exists() {
    let meta = fs::metadata(&socket_path)?;
    if meta.file_type().is_socket() && meta.uid() == get_current_uid() {
        fs::remove_file(&socket_path)?;
    } else {
        warn!("Refusing to delete socket: ownership/type mismatch");
    }
}
```

### ❌ Anti-Pattern: Non-atomic config file writes
**Problem:** Power loss or crash can corrupt config file
```rust
// ❌ BAD: Direct write (not atomic)
fs::write(config_path, toml_string)?;
```
**✅ Solution:** Write to temp file, set permissions, then atomic rename
```rust
// ✅ GOOD: Atomic save with correct permissions
use tempfile::NamedTempFile;
use std::os::unix::fs::PermissionsExt;

let dir = config_path.parent().context("No parent dir")?;
let mut temp = NamedTempFile::new_in(dir)?;
temp.write_all(toml_string.as_bytes())?;
temp.as_file().sync_all()?;

#[cfg(unix)]
fs::set_permissions(temp.path(), fs::Permissions::from_mode(0o600))?;

temp.persist(config_path)?; // Atomic rename
```

### ❌ Anti-Pattern: Exposing mutable internal state unnecessarily
**Problem:** Breaks encapsulation, makes refactoring harder
```rust
// ❌ BAD: Public mutable field
pub struct App {
    pub status_message: Option<String>, // Direct mutation everywhere
}
```
**✅ Solution:** Provide minimal accessors, keep fields private
```rust
// ✅ GOOD: Private field with controlled access
pub struct App {
    status_message: Option<String>, // Private
}

impl App {
    pub fn status_message(&self) -> Option<&str> {
        self.status_message.as_deref()
    }

    pub fn set_status(&mut self, msg: impl Into<String>) {
        self.status_message = Some(msg.into());
    }
}
```

## Code Quality Standards

**All new code must adhere to these standards:**

### Clippy Compliance

Run both standard and pedantic clippy before committing:
```bash
# Standard clippy (must pass with zero warnings)
cargo clippy --all-targets

# Pedantic mode (current state: 0 warnings)
cargo clippy --all-targets -- -W clippy::pedantic
```

**Current Acceptable Pedantic Allows (20 total: 18 centralized, 2 in generated code, 1 in Cargo.toml):**

These suppressions are documented and justified (as of 2025-12-24 after Code Quality Pass):

**Centralized in Cargo.toml `[lints]` table (18 suppressions for 3 lint types):**
- `struct_excessive_bools` (3×) → Config `Settings`, `SettingsFile`, and TUI `App` have independent boolean flags for different features (not state machines)
- `too_many_lines` (14×) → Daemon event loop, TUI event loop, TUI screens, input handlers, commands - cohesive logic hard to split meaningfully
- `match_same_arms` (1×) → Rule editor input - conceptually different field types despite similar-looking actions

**Local suppressions (2 in generated code, 1 in Cargo.toml `[lints]` table):**
- `needless_raw_string_hashes` (1×) → Generated by build.rs (built_info crate) - kept in src/lib.rs
- `doc_markdown` (1×) → Generated by build.rs (built_info crate) - kept in src/lib.rs
- `unexpected_cfgs` (1×) → Cargo.toml warning-level lint for `cfg(test)` validation

**Note:** The centralized `[lints]` table approach (Rust 1.74+) allows workspace-wide configuration while keeping generated code suppressions co-located with their source.

**Recently Fixed (demonstrating thoughtful code quality decisions):**
- `items_after_statements` → Fixed by moving constants to top of scope
- `cast_possible_truncation` → Fixed by using `try_from` and `saturating_sub`
- `needless_pass_by_value` → Fixed by passing `&Connection` instead of moving it
- `too_many_arguments` → Fixed by bundling parameters into `RulesRenderContext` struct
- `if_not_else` → Fixed by swapping branches (simple case first, complex logic in else)

**Policy:** Prefer fixing warnings over adding new `#[allow(...)]` attributes. Each `#[allow]` must have a comment explaining why it's necessary. When a warning can be reasonably fixed through refactoring, fix it rather than suppress it.

### Documentation Requirements

Every public function returning `Result` must have:
```rust
/// Brief description of what the function does
///
/// # Errors
/// Clear description of when/why this returns an error
pub fn example() -> Result<()> { ... }
```

Functions that may panic (using `expect()` or similar) must document:
```rust
/// # Panics
/// Description of panic conditions (even if "should never happen")
```

Technical terms must use backticks in documentation and code comments:
- ✅ `PipeWire`, `app_id`, `IPC`, `XDG_RUNTIME_DIR`, `pw-dump`, `crossterm`, `ratatui`
- ❌ PipeWire, app_id, IPC, XDG_RUNTIME_DIR, pw-dump, crossterm, ratatui
- This includes: protocol names, command-line tools, environment variables, technical identifiers, and library names

### Code Quality Patterns

**Error Handling:**
- Use `color_eyre::eyre::Result` and `Context` for rich error propagation in application code
- Avoid `.expect()` in production paths (only for defensive checks that should never fail)
- Document all panic conditions with `# Panics`
- Check process exit codes with `.status()?.success()`, not just spawn errors

**Efficiency:**
- Prefer `clone_from()` over reassignment: `string.clone_from(&other)` instead of `string = other.clone()`
- Use `map_or()` / `map_or_else()` instead of `map().unwrap_or()`
- Use `is_some_and()` instead of `map().unwrap_or(false)`
- Dereference before `to_string()`: `(*str_ref).to_string()` instead of `str_ref.to_string()`

**Modern Patterns:**
- Use `let-else` for early returns: `let Ok(value) = result else { return false };`
- Derive `Copy` for simple enums when possible
- Use `#[must_use]` on functions that return important values (but document why with `# Panics` if caller ignores)

**Borrow-Checker Snapshot Pattern:**
When you need both immutable and mutable borrows in render/update paths:
1. Snapshot read-only data first (clone/copy small values into local variables)
2. Let immutable borrows go out of scope
3. Then take mutable borrows
4. Prefer this over adding `RefCell`/`Mutex` just to bypass borrow checker

**Visibility & API Surface Design:**
Minimize public API surface to make refactoring easier and prevent accidental misuse:

- **Default to private**: Start with private visibility, only widen as needed
- **Use `pub(crate)` sparingly**: Only for items used across modules within the same crate
- **Provide accessors instead of public fields**: Encapsulate state behind methods
- **Mark test helpers with `#[cfg(test)]`**: Never expose test utilities in production builds
- **Use `#[must_use]` on functions that return values**: Catch accidental ignoring of results

```rust
// ❌ BAD: Everything public
pub struct Config {
    pub field1: String,
    pub field2: u32,
}

// ✅ GOOD: Private fields with controlled access
pub struct Config {
    field1: String,
    field2: u32,
}

impl Config {
    pub fn field1(&self) -> &str {
        &self.field1
    }

    pub fn set_field1(&mut self, value: String) {
        self.field1 = value;
    }
}
```

**Guideline:** If a struct field or function is only used within one module, keep it private. If used across modules in the crate, use `pub(crate)`. Only use `pub` for true public API items.

### Performance Patterns: Async vs Blocking Decision Tree

**When to use `spawn_blocking`:**
- All PipeWire operations (`pw-dump`, `pw-cli`, `pw-metadata`)
- File I/O operations (reading/writing config, large files)
- Regex compilation (if done at runtime)
- Any operation that might take >100ms

**When to use regular async:**
- IPC request/response handling
- Event processing in daemon loop
- State updates (in-memory operations)
- Wayland protocol events (already in separate thread)

**Example pattern:**
```rust
pub async fn activate_sink(&self, sink_name: &str) -> Result<()> {
    let sink = sink_name.to_string();
    tokio::task::spawn_blocking(move || {
        // Blocking PipeWire work here
        Self::activate_sink_blocking(&sink)
    }).await?
}
```

**TUI Rendering Strategy:**
- Event-driven rendering with 60 FPS frame rate cap
- All state changes set `app.dirty = true` flag
- Render loop runs after every `tokio::select!` iteration
- Frame rate limiter prevents excessive redraws (16ms minimum between frames)
- Tick interval (16ms) used only for animations, not driving renders
- Result: Immediate responsiveness (<16ms latency) with efficient CPU usage

**When adding new input handlers:**
- Always set `app.dirty = true` after state changes
- Rendering happens automatically in main loop
- No need to call `terminal.draw()` directly in handlers

### Security Practices

**Command Execution:**
- Always use proper JSON serialization (`serde_json::json!`) instead of string formatting
- Never construct shell commands with user input
- Validate all external command outputs
- Check both spawn success AND exit status: `output.status.success()`

**IPC Security:**
- Unix sockets must have `0o600` permissions (user-only access)
- Validate message sizes before allocation
- Use length-prefixed protocol to prevent injection attacks

**File Operations:**
- Use `path.display()` instead of Debug formatting (`{:?}`) in user-facing messages
- Set explicit permissions on created files/sockets: `fs::Permissions::from_mode(0o600)`
- Verify ownership before deleting: `metadata.uid() == users::get_current_uid()`
- Verify file type before operations: `metadata.file_type().is_socket()`
- Clean up stale files before binding sockets
- Use atomic writes (temp file + rename) for important files like configs

**Atomic File Writes Pattern:**
```rust
use tempfile::NamedTempFile;
use std::os::unix::fs::PermissionsExt;

let dir = path.parent().context("No parent directory")?;
let mut temp = NamedTempFile::new_in(dir)?;
temp.write_all(content.as_bytes())?;
temp.as_file().sync_all()?;

#[cfg(unix)]
fs::set_permissions(temp.path(), fs::Permissions::from_mode(0o600))?;

temp.persist(path)?; // Atomic rename on POSIX
```

### Terminal Styling

All CLI commands use semantic styling via `crossterm` for consistent, readable output:

**Style Module (`src/style.rs`):**
- Single-trait extension (`PwswStyle`) that adds semantic methods to `crossterm::style::Stylize`
- All styling must go through this trait (never use raw ANSI codes or direct `crossterm` colors)
- Pattern: Import both `crossterm::style::Stylize` and `crate::style::PwswStyle` in files that need styling

**Color Scheme ("Moderate+" approach):**
- `.header()` - Cyan bold for section headers (e.g., "ACTIVE SINKS:", "Daemon")
- `.success()` - Green for positive states (e.g., "Running", "active", success messages)
- `.error()` - Red for problems (e.g., "Not running", "not found", error messages)
- `.warning()` - Yellow for warnings or partial states (e.g., "profile switch", warnings)
- `.technical()` - Cyan for technical content (e.g., regex patterns, counts, paths)
- `.bold()` - Direct from `Stylize` for important identifiers (e.g., node names, descriptions)
- `.dim()` - Direct from `Stylize` for secondary information (e.g., labels, markers)

**Ownership Note:**
- Style methods consume their receiver (take ownership)
- For borrowed values like `&String`, use `.as_str()` before styling: `sink.name.as_str().bold()`
- For owned values or `&str`, call directly: `"Header".header()`

**Usage:** Terminal styling is used by both CLI commands and the TUI (via shared `crossterm` dependency).

## Testing Standards

### Test Isolation (CRITICAL)

**Tests MUST NOT touch real user config (`~/.config/pwsw/config.toml`)**

All tests must use isolated temporary XDG directories. This is a **non-negotiable safety requirement** - violating this can corrupt user data.

**Mandatory patterns:**
```rust
use crate::test_utils::XdgTemp;

#[test]
fn test_config_loading() {
    let _guard = XdgTemp::new(); // Isolates XDG_CONFIG_HOME
    // Test code here - safe to use Config::load()
} // Cleanup automatic on drop
```

**Requirements:**
- Use `XdgTemp` for any test calling `Config::load()` (default path)
- Use explicit `TempDir` for tests using `Config::load_from_path()`
- Never hardcode paths to `~/.config/pwsw`
- Never assume test environment is isolated without using `XdgTemp`

**Mandatory verification before pushing to remote:**
```bash
bash scripts/verify_tests_safe.sh  # MUST pass - zero tolerance
```

This script ensures no test reads from or writes to real `~/.config/pwsw`. Failures indicate unsafe tests that could corrupt user data.

### Test Organization

**Three-tier test structure:**

1. **Inline unit tests** (`#[cfg(test)]` modules in src/)
   - Test individual functions/methods in the same file
   - Have full access to private items
   - Fast, isolated, deterministic
   - Examples: config validation, rule matching, JSON parsing

2. **Subsystem integration tests** (e.g., `src/tui/tests/`)
   - Test subsystem integration that needs `pub(crate)` access
   - Appropriate when testing internal APIs not exposed publicly
   - Example: `src/tui/tests/forwarder.rs` tests async channel behavior

3. **Public API integration tests** (`tests/` directory)
   - Test cross-module behavior through public API only
   - Cannot access `pub(crate)` or private items
   - Examples: config lifecycle, CLI smoke tests

**Guidelines:**
- Keep inline tests for unit tests of the same module
- Use `tests/` for true integration tests (full lifecycle, CLI commands)
- Only create `src/module/tests/` when you need internal access for integration testing
- This matches Rust conventions: https://doc.rust-lang.org/book/ch11-03-test-organization.html

### Test Fixtures and Utilities

**Shared test fixtures** (`src/test_utils.rs::fixtures`):
```rust
use crate::test_utils::fixtures::{make_config, make_sink, make_rule};

let config = make_config(
    vec![make_sink("sink1", "Built-in Audio", true)],
    vec![make_rule("firefox", None, "sink1")]
);
```

**XDG isolation** (`src/test_utils.rs::XdgTemp`):
```rust
use crate::test_utils::XdgTemp;

#[test]
fn test_config_loading() {
    let _guard = XdgTemp::new(); // Isolates XDG_CONFIG_HOME
    // Test code here - safe to use Config::load()
} // Cleanup automatic on drop
```

**When to use:**
- Use `fixtures::make_*` helpers instead of duplicating test setup
- Use `XdgTemp` for any test that calls `Config::load()` (uses default path)
- Use manual `TempDir` for tests using explicit paths like `Config::load_from_path()`

### Parameterized Tests

**Use `rstest` for complex parameterization:**
```rust
use rstest::rstest;

#[rstest]
#[case("valid_input", expected_output)]
#[case("edge_case", expected_edge)]
fn test_behavior(#[case] input: &str, #[case] expected: &str) {
    assert_eq!(process(input), expected);
}
```

**Use `test-case` for simpler parameterization:**
```rust
use test_case::test_case;

#[test_case("firefox", "mozilla.firefox", true ; "partial match")]
#[test_case("chrome", "firefox", false ; "no match")]
fn test_matching(pattern: &str, input: &str, should_match: bool) {
    assert_eq!(matches(pattern, input), should_match);
}
```

**Guidelines:**
- Prefer parameterization over duplicate test functions
- Use descriptive case names that show in test output
- Keep test cases simple - complex setup may warrant separate tests

### Test Assertions

**Use `pretty_assertions` for better diagnostics:**
```rust
// At top of test module:
use pretty_assertions::assert_eq;

// Failed assertions show colored diffs automatically
assert_eq!(complex_struct_actual, complex_struct_expected);
```

**Standard assertion guidelines:**
- Use `assert_eq!` / `assert_ne!` for equality checks
- Use `assert!(condition, "message with {context}")` with descriptive messages
- Use `.expect("Clear message")` instead of `.unwrap()` in tests
- Test both success and failure paths

### Running Tests

**Full test suite:**
```bash
cargo test                      # Run all tests
cargo test --lib                # Unit tests only
cargo test --test cli_smoke     # Specific integration test
cargo test config::tests        # Tests in specific module
```

**With safety verification:**
```bash
cargo test && bash scripts/verify_tests_safe.sh
```

**Verification cycle (before pushing commits):**
```bash
cargo fmt                                              # Format
cargo test                                             # All tests
bash scripts/verify_tests_safe.sh                     # Safety check
cargo clippy --all-targets                             # Standard lint
cargo clippy --all-targets -- -W clippy::pedantic      # Pedantic lint
```

**Note:** Running verification after each local commit is recommended but optional. Running it before `git push` is **mandatory** - zero tolerance for failures.

### Test Coverage Areas

**Current coverage (123 tests):**
- ✅ Config validation and parsing (18 tests)
- ✅ TUI logic and components (16 tests)
- ✅ PipeWire JSON parsing and env vars (14 tests)
- ✅ State management and rule matching (13 tests, parameterized)
- ✅ IPC serialization and socket handling (11 tests)
- ✅ Notification icon detection (6 tests)
- ✅ CLI smoke tests (5 tests)
- ✅ Config integration lifecycle (5 tests)
- ✅ Doc tests (2 tests - style trait, widgets)

**Testing philosophy:**
- Focus on critical business logic (rule matching, sink switching)
- Test error handling and validation thoroughly
- Integration tests for cross-module behavior
- Smoke tests for user-facing commands
- Don't over-test simple getters/setters
- TUI rendering is hard to test - focus on logic not visual output

### Writing New Tests

**Checklist for new tests:**
1. ✅ Use shared fixtures from `test_utils::fixtures` if applicable
2. ✅ Use `XdgTemp` if testing config loading with default paths
3. ✅ Use `pretty_assertions::assert_eq` for struct comparisons
4. ✅ Consider parameterization for multiple similar cases
5. ✅ Use descriptive test names: `test_behavior_when_condition`
6. ✅ Include doc comment explaining what's being tested (if non-obvious)
7. ✅ Ensure tests are isolated (no shared mutable state)
8. ✅ Verify test passes: `cargo test test_name`

**Example test structure:**
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::fixtures::{make_config, make_sink};
    use pretty_assertions::assert_eq;

    #[test]
    fn test_descriptive_name_of_behavior() {
        // Arrange: Set up test data
        let config = make_config(vec![make_sink("test", "Test", true)], vec![]);

        // Act: Execute the behavior being tested
        let result = config.get_default_sink();

        // Assert: Verify expected outcome
        assert!(result.is_some());
        assert_eq!(result.unwrap().name, "test");
    }
}
```

### Test Anti-Patterns

**Avoid:**
- ❌ Duplicate test helpers - use `test_utils::fixtures`
- ❌ Testing without isolation - always use `XdgTemp` for config tests
- ❌ Hardcoded paths to real config - tests must not touch `~/.config/pwsw`
- ❌ Tests that depend on external state (running daemon, PipeWire, etc.)
- ❌ Tests that depend on each other (run order matters)
- ❌ Overly complex test setup - consider using rstest fixtures
- ❌ Testing implementation details - test behavior, not internals

**Prefer:**
- ✅ Shared fixtures and utilities
- ✅ Temporary directories and isolation
- ✅ Mocking/stubbing external dependencies (where possible)
- ✅ Independent, order-agnostic tests
- ✅ Simple, focused tests with clear assertions
- ✅ Testing public behavior and contracts

## Repository Scripts

### Verification & Automation Scripts

**`scripts/verify_tests_safe.sh`** (Critical - MUST pass before pushing to remote)
- Validates that tests don't modify real user config
- Checks for hardcoded paths to `~/.config/pwsw`
- Ensures `XdgTemp` pattern is used correctly
- Returns non-zero exit code if unsafe patterns detected
- **Zero tolerance** - failures indicate unsafe tests that could corrupt user data

**`scripts/install_git_hook.sh`**
- Sets up pre-commit hooks for automatic validation
- Runs formatting, tests, and safety checks before allowing commit
- Recommended for all contributors

**Usage:**
```bash
# One-time setup
bash scripts/install_git_hook.sh

# Manual verification (run before commits if hooks not installed)
bash scripts/verify_tests_safe.sh
```

## Build Commands

### Development
```bash
# Build in debug mode
cargo build

# Build with optimizations
cargo build --release

# Check without building
cargo check

# Run tests (with safety verification)
cargo test && bash scripts/verify_tests_safe.sh

# Run clippy for linting
cargo clippy --all-targets
cargo clippy --all-targets -- -W clippy::pedantic

# Format code
cargo fmt
```

### Installation
```bash
# Install to ~/.cargo/bin/
cargo install --path .

# The binary will be at:
# - Debug: target/debug/pwsw
# - Release: target/release/pwsw
```

### Running
```bash
# Start daemon in foreground (for debugging)
cargo run -- daemon --foreground

# Start daemon in background
cargo run -- daemon

# CLI commands (require running daemon for IPC commands)
cargo run -- status
cargo run -- list-sinks
cargo run -- list-windows
cargo run -- test-rule "^firefox$"
cargo run -- validate

# TUI mode (interactive interface)
cargo run -- tui
```

### systemd User Service

For automatic daemon startup on login, a systemd user service is available in `contrib/systemd/`:

```bash
# Install the service
mkdir -p ~/.config/systemd/user
cp contrib/systemd/pwsw.service ~/.config/systemd/user/

# Enable and start the service
systemctl --user daemon-reload
systemctl --user enable --now pwsw.service

# Check status
systemctl --user status pwsw.service

# View logs
journalctl --user -u pwsw.service -f
```

**Note:** Update the `ExecStart` path in the service file if you installed `pwsw` somewhere other than `~/.cargo/bin/pwsw`.

See `contrib/systemd/README.md` for complete installation, management, and troubleshooting instructions.

## Architecture

### Core Components

**Daemon Mode (`daemon.rs`)**
- Main event loop using `tokio::select!` to multiplex:
  - Compositor window events (via mpsc channel from Wayland thread)
  - IPC requests from CLI clients (via Unix socket)
  - Config file watch events (via `notify` crate)
  - Shutdown signals (Ctrl-C or IPC shutdown request)
- Owns the State and manages the lifecycle
- All blocking operations (PipeWire calls) use `spawn_blocking`

**State Management (`state.rs`)**
- Tracks active windows that matched rules (HashMap<u64, ActiveWindow>)
- Implements rule matching logic (app_id + optional title regex)
- Priority system: most recently opened matching window wins
- When windows close or stop matching, determines target sink from remaining active windows
- Falls back to default sink when no rules match
- `process_event()` is async and uses `spawn_blocking` for sink activation

**IPC Infrastructure (`ipc.rs`)**
- Unix socket-based client-server communication
- Length-prefixed JSON protocol (4-byte big-endian length + JSON payload)
- Socket location: `$XDG_RUNTIME_DIR/pwsw.sock` or `/tmp/pwsw-$USER.sock`
- Socket permissions: `0o600` (user-only access for security)
- Automatic stale socket cleanup on daemon start with ownership verification
- Request types: Status, Reload, ListWindows, TestRule, Shutdown
- Response types: Status, Ok, Error, Windows, RuleMatches
- Window identity uses unique IDs (not app_id/title pairs) for correctness

**Compositor Abstraction (`compositor/mod.rs`)**
- Protocol detection via Wayland registry scan
- Spawns dedicated `std::thread` for Wayland event loop (Wayland is not async-friendly)
- Sends WindowEvent enum (Opened, Changed, Closed) to tokio runtime via unbounded mpsc channel
- Implementation: `wlr_toplevel.rs` for wlr-foreign-toplevel-management protocol (Sway, Hyprland, Niri, River, etc.)
- Graceful shutdown on channel closure

**PipeWire Integration (`pipewire.rs`)**
- Parses `pw-dump` JSON output for sinks, devices, profiles, and metadata
- Active sinks: Audio/Sink nodes currently available
- Profile sinks: Predicted node names for sinks that require profile switching
- Profile switching workflow:
  1. Acquire per-device lock to serialize switches on same device
  2. Call `pw-cli` to switch device profile (uses proper JSON serialization)
  3. Wait with retries (150ms × 5 max) for new sink node to appear
  4. Set as default with `pw-metadata`
- Node name prediction: `alsa_output.{device_suffix}.{profile_suffix}`
- **Concurrency:** Profile switching uses per-device `std::sync::Mutex` to prevent concurrent switches on same device
- **Performance:** All operations use `spawn_blocking` to avoid blocking tokio runtime

**Configuration (`config.rs`)**
- TOML format at `$XDG_CONFIG_HOME/pwsw/config.toml`
- Validation rules:
  - Exactly one default sink required
  - No duplicate sink names or descriptions
  - All rule sink references must resolve (by position, desc, or name)
  - Log level must be valid
- Creates default config if none exists
- Sink references support: 1-indexed position, description, or node name
- **Atomic saves:** Write to temp file → set 0o600 permissions → atomic rename
- **Hot-reload:** Daemon watches config file with `notify` crate, validates on change

**TUI Mode (`src/tui/`)**
- Interactive terminal UI built with `ratatui` and `crossterm`
- Features:
  - Real-time sink and window monitoring
  - Rule editing with live preview
  - Config editing with validation
  - Daemon status and control
  - Integrated help system
- Components:
  - `app.rs` - Main application state and event handling
  - `mod.rs` - Event loop and rendering coordination
  - `input.rs` - Text input widget using `tui-input` crate
  - `screens/` - Individual screen implementations (rules, sinks, settings, help)
  - `widgets.rs` - Shared UI components (scroll arrows, sink selectors)
  - `preview.rs` - Rule matching preview logic
- **Architecture:** Uses snapshot pattern to avoid borrow-checker conflicts (see Anti-Patterns section)
- **Logging:** Integrated with `tui-logger` for in-TUI log viewing
- **Error Handling:** Uses `color-eyre` for rich error reports with backtraces
- **Performance:** Event-driven rendering with 60 FPS frame rate cap
  - Changed from tick-based (80ms) to event-driven with frame limiter (16ms max latency)
  - Result: ~62.5 FPS sustained, <16ms input latency (down from 0-80ms avg)
  - Implementation: Restructured event loop in `src/tui/mod.rs:424-567`
  - Impact: Matches native terminal application responsiveness

**Notifications (`notification.rs`)**
- Desktop notifications using `notify-rust`
- Icon auto-detection from sink/app descriptions
- May fail silently if no notification daemon available
- Used for manual switches and rule-based switches (configurable)

### Data Flow

1. **Window Event Flow**:
   - Wayland compositor emits protocol events
   - Compositor thread receives and converts to WindowEvent
   - Sent via mpsc channel to daemon's tokio runtime
   - State processes event (async) and determines if sink switch is needed
   - `PipeWire::activate_sink()` called via `spawn_blocking` if switch required

2. **IPC Request Flow**:
   - CLI client connects to Unix socket
   - Sends length-prefixed JSON request
   - Daemon spawns tokio task to handle request
   - Task reads current state snapshot (no shared mutable state)
   - Response written back to same socket
   - Window info includes unique IDs for accurate tracking

3. **Profile Switching Flow**:
   - Check if sink is active (quick path: just set default)
   - If not active, check profile_sinks for predicted name
   - Acquire device-specific lock (serialize switches per device)
   - Switch device profile with `pw-cli`
   - Poll with retries for new sink node to appear
   - Set as default with `pw-metadata`
   - Release lock

4. **Config Hot-Reload Flow**:
   - `notify` crate watches config directory
   - Filter events to only actual config file changes
   - Debounce rapid events via `try_send` (avoid blocking watcher)
   - Validate new config before signaling daemon
   - Daemon reloads config but does not auto-restart (requires manual restart for changes to take effect)

### Threading Model

- **Main Tokio Runtime**: Runs daemon event loop, IPC server, signal handlers, config watcher
- **Wayland Thread**: Dedicated `std::thread` for Wayland event loop (blocking, not async)
- **IPC Handler Tasks**: Spawned tokio tasks for each IPC connection (non-blocking)
- **Blocking Workers**: `spawn_blocking` tasks for PipeWire operations (pool managed by tokio)

State is owned by the main loop. IPC handlers clone only what they need (uptime, current_sink_name, tracked windows list) to avoid shared mutable state. Per-device profile locks use `std::sync::Mutex` (safe in `spawn_blocking`).

### Key Design Patterns

**Priority-based sink switching**: Most recent matching window wins. When it closes, next most recent takes over.

**Predicted node names**: Profile sinks use string manipulation to predict the node name before switching (enables config validation).

**Protocol abstraction**: WindowEvent enum allows adding new compositor protocols without changing daemon logic.

**No config hot-reload restart**: Reload command validates config but requires daemon restart for changes to take effect. This avoids complex state synchronization.

**Snapshot pattern for renders**: TUI render code snapshots read-only data before taking mutable borrows to avoid borrow-checker conflicts (see Anti-Patterns section).

**Async + blocking hybrid**: Async event loop with `spawn_blocking` for PipeWire calls to avoid blocking runtime.

## Configuration Notes

### Finding Window App IDs and Titles

Different compositors provide different tools:
- Sway/River/wlroots: `swaymsg -t get_tree`
- Hyprland: `hyprctl clients`
- Niri: `niri msg windows`
- KDE Plasma: KDE's window inspector
- Or use: `pwsw list-windows` (while daemon is running)
- TUI: `pwsw tui` → Windows tab shows all tracked windows

### Regex Pattern Syntax

Window rules support full Rust regex syntax:
- `"firefox"` - matches anywhere in string
- `"^steam$"` - exact match only
- `"^(mpv|vlc)$"` - matches mpv OR vlc
- `"(?i)discord"` - case insensitive

Both app_id and title support regex. If title is omitted, any title matches.

**Pattern Testing:**
```bash
# CLI testing
pwsw test-rule "^firefox$"
pwsw test-rule "^.*Discord.*$"

# TUI testing
pwsw tui  # Rules tab has live preview of matches
```

### Sink Icon Auto-detection

Icons are auto-detected from sink descriptions:
- "HDMI" → video-display
- "headphone" → audio-headphones
- "speaker" → audio-speakers
- "analog" → audio-card
- Override with explicit `icon = "..."` in config

### Environment Variables

**Profile Switch Tuning** (for audio devices with slow initialization):

- `PROFILE_SWITCH_DELAY_MS` - Time to wait between retries when waiting for sink node to appear after profile switch (default: 150ms)
- `PROFILE_SWITCH_MAX_RETRIES` - Maximum number of retries when polling for new sink node (default: 5)

These parameters are rarely needed but can be adjusted for devices that take longer to initialize after profile switching.

**Example usage:**
```bash
# Increase delay for slow device
PROFILE_SWITCH_DELAY_MS=300 pwsw daemon

# Increase both delay and retries
PROFILE_SWITCH_DELAY_MS=200 PROFILE_SWITCH_MAX_RETRIES=10 pwsw daemon
```

**When to adjust:**
- If you see errors like "sink did not appear after N attempts" during profile switches
- When switching between analog outputs (headphones/speakers) on the same device
- Total wait time = delay × retries (default: 150ms × 5 = 750ms)

## Testing

### Manual Testing Workflow

When making changes to window matching or state management logic, test with:
```bash
# Start daemon in foreground to see logs
pwsw daemon --foreground

# In another terminal:
pwsw list-windows        # See what windows daemon knows about
pwsw test-rule "^mpv$"   # Test regex patterns
pwsw status              # Check current state

# Or use the TUI
pwsw tui                 # Interactive interface with live updates
```

For PipeWire integration changes:
```bash
pwsw list-sinks          # See active and profile sinks
pwsw validate            # Check config without starting daemon
```

### Automated Testing

Run the full test suite with safety verification:
```bash
# Run all tests
cargo test

# Verify tests don't touch real config (CRITICAL)
bash scripts/verify_tests_safe.sh

# Check for clippy issues
cargo clippy --all-targets
cargo clippy --all-targets -- -W clippy::pedantic
```

## Common Gotchas

1. **Wayland thread panics**: The Wayland event loop runs in a separate thread. If it panics, the mpsc channel closes and daemon shuts down gracefully. The event loop properly detects channel closure. Check thread spawn in `compositor/mod.rs`.

2. **Stale sockets**: If daemon crashes, the Unix socket may remain. Next daemon start auto-cleans stale sockets with ownership/type verification (500ms timeout health check). Socket permissions are enforced (`0o600`) on creation.

3. **Profile switch timing**: Some audio devices take >150ms to create new sink nodes after profile switch. If switches fail, increase `PROFILE_SWITCH_DELAY_MS` or `PROFILE_SWITCH_MAX_RETRIES` in `pipewire.rs`. Note: Per-device locks prevent concurrent profile switches on same device.

4. **Regex validation**: Config validation compiles all regexes at load time. If a rule has invalid regex, daemon won't start. Be aware of catastrophic backtracking with complex patterns. Test patterns with `pwsw test-rule` before adding to config.

5. **Default sink requirement**: Config must have exactly one sink with `default = true`. Daemon will fail to start otherwise. This is enforced at config validation time.

6. **Unsupported compositors**:
   - GNOME/Mutter doesn't expose window management protocols
   - KDE Plasma 6 removed the plasma-window-management protocol and hasn't implemented a replacement yet
   - These are compositor limitations, not code issues

7. **Protocol version compatibility**: The code validates Wayland protocol versions (wlr: 1-3). If a compositor advertises an incompatible version, binding will fail with a clear error.

8. **Health check timeout**: IPC health checks use a 500ms timeout to accommodate slow systems and high load scenarios. This prevents false negatives during daemon startup.

9. **Test isolation**: Always use `XdgTemp` in tests that touch config. Running tests without this will fail safety verification (`scripts/verify_tests_safe.sh`).

10. **Blocking calls in async**: Never call `pw-dump`, `pw-cli`, or other blocking commands directly in async functions. Always use `spawn_blocking`. See Anti-Patterns section above.

## Known Issues & Limitations

### Memory Usage
- `all_windows` HashMap duplicates some data from `active_windows` (intentional for `test-rule` command and TUI display)
- IPC handlers clone config and window data on each request (not critical for single-user daemon)
- TUI maintains additional state for rendering (config snapshots, cached regex compilations)

### Security Notes
- Socket permissions (`0o600`) prevent unauthorized access on multi-user systems
- All external commands (`pw-dump`, `pw-cli`, `pw-metadata`) use proper JSON serialization
- No authentication beyond filesystem permissions (Unix socket is local-only)
- Complex regex patterns in rules could cause performance issues (catastrophic backtracking)
- Stale socket cleanup verifies ownership and file type before deletion

### Compositor Protocol Support

**Current Status:**
- **Supported:** `zwlr_foreign_toplevel_manager_v1` (wlroots/Smithay compositors)
- **Supported:** `ext_foreign_toplevel_list_v1` (Standard protocol, staging)
- **Not Supported:** GNOME/Mutter, KDE Plasma 6 (until they implement `ext`)

**Protocol History:**

*KDE Plasma Support (Removed December 2024):*
- Plasma 5 supported `org_kde_plasma_window_management` protocol
- Initial implementation added in v0.2.0 but marked experimental/untested
- Plasma 6 (released February 2024) removed this protocol entirely
- Support was dropped after confirming Plasma 6 has no window management protocol
- Removed files: `src/compositor/plasma.rs`, `wayland-protocols-plasma` dependency

**Protocol Details:**

*ext-foreign-toplevel-list v1:*
- Part of official wayland-protocols (staging state)
- Standardized replacement for wlr-foreign-toplevel-management
- **Implementation (2025-12-24):** Added as preferred backend in `src/compositor/ext_toplevel.rs`.
- **Key difference:** Read-only list of toplevels (no window control capabilities). This is ideal for `pwsw`'s monitoring-only needs.
- **Current adoption:** Growing. Enables broader compositor support as adoption increases.

**Resources:**
- wayland-protocols repository: https://gitlab.freedesktop.org/wayland/wayland-protocols
- ext-foreign-toplevel spec: `staging/ext-foreign-toplevel-list/`

**Decision rationale:**
- Prioritize standard protocols (`ext`) over vendor-specific ones (`wlr`) while maintaining both for maximum compatibility.
- Ensure the daemon remains lightweight by utilizing the read-only protocol where possible.

## Code Location Quick Reference

**Core Daemon:**
- CLI parsing: `src/cli.rs`
- CLI command implementations: `src/commands.rs`
- Daemon entry point: `src/bin/pwsw.rs`
- Main daemon loop: `src/daemon.rs`
- State machine: `src/state.rs`

**Integration:**
- Wayland integration: `src/compositor/mod.rs`, `src/compositor/wlr_toplevel.rs`
- PipeWire control: `src/pipewire.rs`
- IPC protocol: `src/ipc.rs`
- Config parsing: `src/config.rs`
- Notifications: `src/notification.rs`

**TUI:**
- Main TUI app: `src/tui/app.rs`
- Event loop & rendering: `src/tui/mod.rs`
- Text input widget: `src/tui/input.rs`
- Rule matching preview: `src/tui/preview.rs`
- Shared widgets: `src/tui/widgets.rs`
- Screens: `src/tui/screens/` (rules, sinks, settings, help)

**Utilities:**
- Terminal styling: `src/style.rs`
- Test helpers: `src/test_utils.rs`

## Dependencies to Be Aware Of

### Core Functionality
- `wayland-client`: Handles Wayland protocol bindings (not async)
- `wayland-protocols`: Standard protocol definitions (staging features used for `ext`)
- `tokio`: Async runtime (minimal features: rt-multi-thread, net, io-util, signal, sync, time)
- `regex`: Compiled once during config load, reused for all matching
- `serde_json`: Used for pw-dump parsing, IPC protocol, and secure command construction
- `color-eyre`: Error handling with context chaining (prefer over custom error types)
- `toml` / `serde`: Config file parsing and serialization

### External Tools (must be in PATH)
- `pw-dump` - PipeWire state introspection
- `pw-metadata` - Set default sink
- `pw-cli` - Device profile switching

### TUI & User Interface
- `ratatui`: Terminal UI framework (crossterm backend)
- `crossterm`: Terminal manipulation and styling (used by CLI and TUI)
- `tui-input`: Text input widget with cursor support
- `tui-logger`: Integrated log viewer for TUI
- `throbber-widgets-tui`: Loading spinners for async operations
- `color-eyre`: Enhanced error reports with backtraces and color
- `notify-rust`: Desktop notifications (may fail silently if no daemon)

### File & System Operations
- `notify`: File system watching for config hot-reload
- `tempfile`: Safe temporary file creation for atomic writes
- `users`: UID lookup for ownership verification
- `dirs`: XDG directory standard support

### Utilities
- `tracing` / `tracing-subscriber`: Structured logging
- `clap`: CLI argument parsing (derive API)
- `futures-util`: Async stream utilities

## Development Workflow

### Verification Cycle (Run Before Pushing to Remote)

```bash
# 1. Format code
cargo fmt

# 2. Run tests
cargo test

# 3. Verify test safety (CRITICAL - must pass, zero tolerance)
bash scripts/verify_tests_safe.sh

# 4. Check standard clippy
cargo clippy --all-targets

# 5. Check pedantic clippy
cargo clippy --all-targets -- -W clippy::pedantic

# 6. Manual testing (if relevant)
cargo run -- daemon --foreground  # Start daemon
cargo run -- status                # Test CLI
cargo run -- tui                   # Test TUI
```

**Note:** This cycle is **mandatory** before `git push`. Running it after each local commit is recommended but optional - use your judgment for WIP/experimental commits.

**Automate with git hooks:**
```bash
bash scripts/install_git_hook.sh
```

### Code Review Checklist

When reviewing changes or adding features:
- [ ] All functions have proper documentation with `# Errors` and `# Panics` sections
- [ ] Technical terms use backticks in documentation
- [ ] No new clippy warnings introduced (standard or pedantic)
- [ ] Security: Proper JSON serialization for external commands
- [ ] Security: File/socket permissions set explicitly (`0o600`)
- [ ] Security: Ownership verification before file deletion
- [ ] Error handling: Process exit codes checked with `.status()?.success()`
- [ ] Performance: Blocking operations use `spawn_blocking`
- [ ] Testing: New tests use `XdgTemp` for config isolation
- [ ] Testing: `scripts/verify_tests_safe.sh` passes
- [ ] Borrow checker: Snapshot pattern used for render paths (not `RefCell`)
- [ ] No `expect()` calls in production code paths (only defensive checks)

### Git Commit Messages

Use conventional commits format:
```
<type>: <subject>

<body>
```

**Types:** `feat`, `fix`, `refactor`, `docs`, `chore`, `test`, `perf`

**Guidelines:**
- Subject: Concise (50 chars), imperative mood ("add" not "added")
- Body: Explain WHY, not just what. Reference issues/PRs if applicable.
- Include rationale for non-obvious changes
- Reference planning documents (`tui_plan.md`) if implementing planned features

### Git Push Policy

**Push commits to remote ONLY when explicitly approved by the user.**

**NEVER push changes to remote without explicit user approval.**

When creating commits:
1. Always create the commit locally
2. Inform the user that the commit was created but not pushed
3. Wait for explicit approval (e.g., "push it", "go ahead and push", "yes push") before running `git push`
4. If approved, push with: `git push` (or `git push -u origin <branch>` for new branches)

### Incremental Refactoring Approach

When tackling large refactors (from lessons learned in Phase C.1):

**1. Capture baseline:**
```bash
cargo clippy --all-targets -- -W clippy::pedantic > /tmp/baseline.txt
```

**2. Extract pure logic:**
- Move complex calculations/matching into testable helper functions
- Keep helpers pure (no side effects, no mutable state)
- Add unit tests for helpers

**3. Move items out of functions:**
- Hoist `use`, `const`, type aliases to module level
- Prefer module-level definitions for widely-used items

**4. Consolidate duplicates:**
- Extract duplicated widget rendering into shared helpers
- Create reusable components in `widgets.rs`

**5. Remove dead code:**
- Use `rg`/`git grep` to verify no callers before deletion
- Remove `#[allow(dead_code)]` by actually removing the code

**6. Fix remaining warnings:**
- Prefer refactors and micro-fixes over adding `#[allow(...)]`
- Document each `#[allow]` with inline comment explaining why

**7. Final cleanup:**
- Remove temporary allows where underlying cause was fixed
- Update documentation and refactor plan

**Per-step commit:** Small, reversible commits. Run verification cycle after each. Don't push until phase complete.

### Testing Approach

**Automated Tests (90 total):**
Run the test suite with:
```bash
cargo test              # Run all tests
cargo test --lib        # Run unit tests only
```

Test coverage by module:
- `config.rs`: 18 tests - Config validation, sink resolution, default sink handling
- `tui/`: 16 tests - Input handling, widgets, preview logic, async message passing
- `pipewire.rs`: 14 tests - JSON parsing from `pw-dump` output, env var parsing (no external dependencies)
- `state.rs`: 13 tests - Rule matching, priority logic, window tracking
- `ipc.rs`: 11 tests - Request/Response serialization, socket handling roundtrips
- `notification.rs`: 6 tests - Icon auto-detection for sinks and apps
- `tests/cli_smoke_tests.rs`: 5 tests - Binary execution, help, version, error handling
- `tests/config_integration.rs`: 5 tests - Config save/load, validation, permissions
- Doc tests: 2 tests - Styling trait usage example, widget helpers

All tests use inline `#[cfg(test)]` modules or subsystem test directories (e.g., `src/tui/tests/`). Integration tests in `tests/` verify public API behavior. No tests depend on external PipeWire/Wayland state.

**Manual Testing:**
For features not covered by unit tests, manual testing should cover:
1. **Window matching**: Test regex patterns with `pwsw test-rule` or TUI Rules tab
2. **Sink switching**: Verify correct sink activation with `pwsw status` or TUI Sinks tab
3. **IPC protocol**: Test all CLI commands while daemon is running
4. **Error conditions**: Test with missing tools, invalid config, etc.
5. **Resource cleanup**: Verify socket cleanup on daemon shutdown
6. **Config hot-reload**: Edit config while daemon running, verify validation
7. **TUI functionality**: Navigate all screens, test input, verify real-time updates
