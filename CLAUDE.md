# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

PWSW (PipeWire Switcher) is a Rust daemon that automatically switches PipeWire audio sinks based on active windows in Wayland compositors. It uses the wlr-foreign-toplevel-management protocol to monitor window events and PipeWire native tools (pw-dump, pw-metadata, pw-cli) for audio control.

**IMPORTANT**: This codebase was entirely generated by LLMs without peer review from experienced Rust developers. However, it has undergone comprehensive code review and pedantic clippy cleanup (154 warnings ‚Üí 8 acceptable). Exercise caution when making changes and validate thoroughly.

## Code Quality Standards

**All new code must adhere to these standards:**

### Clippy Compliance
```bash
# Check for all clippy warnings (should pass cleanly)
cargo clippy --all-targets

# Pedantic mode (should have only 8 warnings - see below)
cargo clippy --all-targets -- -W clippy::pedantic
```

**Acceptable Pedantic Warnings (7 total):**
- 2√ó `struct_excessive_bools` ‚Üí Settings struct legitimately needs 5 independent boolean flags (default_on_startup, set_smart_toggle, notify_manual, notify_rules, match_by_index)
- 2√ó `too_many_lines` ‚Üí Daemon event loop (154 lines) and list_sinks command (117 lines) are cohesive and hard to split meaningfully
- 2√ó `items_after_statements` ‚Üí Constants defined in spawn block for scoping
- 1√ó `needless_pass_by_value` ‚Üí Wayland `Connection` must be moved, not borrowed (protocol requirement)

**All other clippy warnings must be fixed before merging.**

### Documentation Requirements

Every public function returning `Result` must have:
```rust
/// Brief description of what the function does
///
/// # Errors
/// Clear description of when/why this returns an error
pub fn example() -> Result<()> { ... }
```

Functions that may panic (using `expect()` or similar) must document:
```rust
/// # Panics
/// Description of panic conditions (even if "should never happen")
```

Technical terms must use backticks in documentation and code comments:
- ‚úÖ `PipeWire`, `app_id`, `IPC`, `XDG_RUNTIME_DIR`, `pw-dump`, `crossterm`
- ‚ùå PipeWire, app_id, IPC, XDG_RUNTIME_DIR, pw-dump, crossterm
- This includes: protocol names, command-line tools, environment variables, technical identifiers, and library names

### Code Quality Patterns

**Error Handling:**
- Use `Result` and `Context` for error propagation
- Avoid `.expect()` in production paths (only for defensive checks that should never fail)
- Document all panic conditions with `# Panics`

**Efficiency:**
- Prefer `clone_from()` over reassignment: `string.clone_from(&other)` instead of `string = other.clone()`
- Use `map_or()` / `map_or_else()` instead of `map().unwrap_or()`
- Use `is_some_and()` instead of `map().unwrap_or(false)`
- Dereference before `to_string()`: `(*str_ref).to_string()` instead of `str_ref.to_string()`

**Modern Patterns:**
- Use `let-else` for early returns: `let Ok(value) = result else { return false };`
- Derive `Copy` for simple enums when possible
- Use `#[must_use]` on functions that return important values

### Security Practices

**Command Execution:**
- Always use proper JSON serialization (`serde_json::json!`) instead of string formatting
- Never construct shell commands with user input
- Validate all external command outputs

**IPC Security:**
- Unix sockets must have `0o600` permissions (user-only access)
- Validate message sizes before allocation
- Use length-prefixed protocol to prevent injection attacks

**File Operations:**
- Use `path.display()` instead of Debug formatting (`{:?}`) in user-facing messages
- Set explicit permissions on created files/sockets
- Clean up stale files before binding sockets

### Terminal Styling

All CLI commands use semantic styling via `crossterm` for consistent, readable output:

**Style Module (`src/style.rs`):**
- Single-trait extension (`PwswStyle`) that adds semantic methods to `crossterm::style::Stylize`
- All styling must go through this trait (never use raw ANSI codes or direct `crossterm` colors)
- Pattern: Import both `crossterm::style::Stylize` and `crate::style::PwswStyle` in files that need styling

**Color Scheme ("Moderate+" approach):**
- `.header()` - Cyan bold for section headers (e.g., "ACTIVE SINKS:", "Daemon")
- `.success()` - Green for positive states (e.g., "Running", "active", success messages)
- `.error()` - Red for problems (e.g., "Not running", "not found", error messages)
- `.warning()` - Yellow for warnings or partial states (e.g., "profile switch", warnings)
- `.technical()` - Cyan for technical content (e.g., regex patterns, counts, paths)
- `.bold()` - Direct from `Stylize` for important identifiers (e.g., node names, descriptions)
- `.dim()` - Direct from `Stylize` for secondary information (e.g., labels, markers)

**Ownership Note:**
- Style methods consume their receiver (take ownership)
- For borrowed values like `&String`, use `.as_str()` before styling: `sink.name.as_str().bold()`
- For owned values or `&str`, call directly: `"Header".header()`

**Future Work:**
- Terminal styling is preparation for future TUI (`pwsw tui` command using `ratatui` + `crossterm`)
- May add TTY detection later to disable colors when piped (not implemented yet)

## Build Commands

### Development
```bash
# Build in debug mode
cargo build

# Build with optimizations
cargo build --release

# Check without building
cargo check

# Run tests (if any exist)
cargo test

# Run clippy for linting
cargo clippy

# Format code
cargo fmt
```

### Installation
```bash
# Install to ~/.cargo/bin/
cargo install --path .

# The binary will be at:
# - Debug: target/debug/pwsw
# - Release: target/release/pwsw
```

### Running
```bash
# Start daemon in foreground (for debugging)
cargo run -- daemon --foreground

# Start daemon in background
cargo run -- daemon

# Other commands (require running daemon for IPC commands)
cargo run -- status
cargo run -- list-sinks
cargo run -- validate
```

## Architecture

### Core Components

**Daemon Mode (`daemon.rs`)**
- Main event loop using tokio::select! to multiplex:
  - Compositor window events (via mpsc channel from Wayland thread)
  - IPC requests from CLI clients (via Unix socket)
  - Shutdown signals (Ctrl-C or IPC shutdown request)
- Owns the State and manages the lifecycle

**State Management (`state.rs`)**
- Tracks active windows that matched rules (HashMap<u64, ActiveWindow>)
- Implements rule matching logic (app_id + optional title regex)
- Priority system: most recently opened matching window wins
- When windows close or stop matching, determines target sink from remaining active windows
- Falls back to default sink when no rules match

**IPC Infrastructure (`ipc.rs`)**
- Unix socket-based client-server communication
- Length-prefixed JSON protocol (4-byte big-endian length + JSON payload)
- Socket location: $XDG_RUNTIME_DIR/pwsw.sock or /tmp/pwsw-$USER.sock
- Socket permissions: 0o600 (user-only access for security)
- Automatic stale socket cleanup on daemon start (500ms health check timeout)
- Request types: Status, Reload, ListWindows, TestRule, Shutdown
- Response types: Status, Ok, Error, Windows, RuleMatches

**Compositor Abstraction (`compositor/mod.rs`)**
- Protocol detection via Wayland registry scan
- Spawns dedicated std::thread for Wayland event loop (Wayland is not async-friendly)
- Sends WindowEvent enum (Opened, Changed, Closed) to tokio runtime via unbounded mpsc channel
- Implementation: `wlr_toplevel.rs` for wlr-foreign-toplevel-management protocol (Sway, Hyprland, Niri, River, etc.)

**PipeWire Integration (`pipewire.rs`)**
- Parses pw-dump JSON output for sinks, devices, profiles, and metadata
- Active sinks: Audio/Sink nodes currently available
- Profile sinks: Predicted node names for sinks that require profile switching
- Profile switching workflow:
  1. Call pw-cli to switch device profile (uses proper JSON serialization)
  2. Wait with retries (150ms √ó 5 max) for new sink node to appear
  3. Set as default with pw-metadata
- Node name prediction: `alsa_output.{device_suffix}.{profile_suffix}`
- **Concurrency**: Profile switching is not thread-safe for concurrent switches on the same device

**Configuration (`config.rs`)**
- TOML format at $XDG_CONFIG_HOME/pwsw/config.toml
- Validation rules:
  - Exactly one default sink required
  - No duplicate sink names or descriptions
  - All rule sink references must resolve (by position, desc, or name)
  - Log level must be valid
- Creates default config if none exists
- Sink references support: 1-indexed position, description, or node name

### Data Flow

1. **Window Event Flow**:
   - Wayland compositor emits protocol events
   - Compositor thread receives and converts to WindowEvent
   - Sent via mpsc channel to daemon's tokio runtime
   - State processes event and determines if sink switch is needed
   - PipeWire::activate_sink() called if switch required

2. **IPC Request Flow**:
   - CLI client connects to Unix socket
   - Sends length-prefixed JSON request
   - Daemon spawns tokio task to handle request
   - Task reads current state snapshot (no shared mutable state)
   - Response written back to same socket

3. **Profile Switching Flow**:
   - Check if sink is active (quick path: just set default)
   - If not active, check profile_sinks for predicted name
   - Switch device profile with pw-cli
   - Poll with retries for new sink node to appear
   - Set as default with pw-metadata

### Threading Model

- **Main Tokio Runtime**: Runs daemon event loop, IPC server, signal handlers
- **Wayland Thread**: Dedicated std::thread for Wayland event loop (blocking, not async)
- **IPC Handler Tasks**: Spawned tokio tasks for each IPC connection (non-blocking)

State is owned by the main loop. IPC handlers clone only what they need (uptime, current_sink_name, tracked windows list) to avoid shared mutable state.

### Key Design Patterns

**Priority-based sink switching**: Most recent matching window wins. When it closes, next most recent takes over.

**Predicted node names**: Profile sinks use string manipulation to predict the node name before switching (enables config validation).

**Protocol abstraction**: WindowEvent enum allows adding new compositor protocols without changing daemon logic.

**No config hot-reload**: "Reload" command validates config but requires daemon restart for changes to take effect. This avoids complex state synchronization.

## Configuration Notes

### Finding Window App IDs and Titles

Different compositors provide different tools:
- Sway/River/wlroots: `swaymsg -t get_tree`
- Hyprland: `hyprctl clients`
- Niri: `niri msg windows`
- KDE Plasma: KDE's window inspector
- Or use: `pwsw list-windows` (while daemon is running)

### Regex Pattern Syntax

Window rules support full Rust regex syntax:
- `"firefox"` - matches anywhere in string
- `"^steam$"` - exact match only
- `"^(mpv|vlc)$"` - matches mpv OR vlc
- `"(?i)discord"` - case insensitive

Both app_id and title support regex. If title is omitted, any title matches.

### Sink Icon Auto-detection

Icons are auto-detected from sink descriptions:
- "HDMI" ‚Üí video-display
- "headphone" ‚Üí audio-headphones
- "speaker" ‚Üí audio-speakers
- "analog" ‚Üí audio-card
- Override with explicit `icon = "..."` in config

## Testing

When making changes to window matching or state management logic, test with:
```bash
# Start daemon in foreground to see logs
pwsw daemon --foreground

# In another terminal:
pwsw list-windows        # See what windows daemon knows about
pwsw test-rule "^mpv$"   # Test regex patterns
pwsw status              # Check current state
```

For PipeWire integration changes:
```bash
pwsw list-sinks          # See active and profile sinks
pwsw validate            # Check config without starting daemon
```

## Common Gotchas

1. **Wayland thread panics**: The Wayland event loop runs in a separate thread. If it panics, the mpsc channel closes and daemon shuts down. However, the event loop properly detects channel closure and shuts down gracefully. Check thread spawn in compositor/mod.rs.

2. **Stale sockets**: If daemon crashes, the Unix socket may remain. Next daemon start auto-cleans stale sockets (500ms timeout health check). Socket permissions are enforced (0o600) on creation.

3. **Profile switch timing**: Some audio devices take >150ms to create new sink nodes after profile switch. If switches fail, increase PROFILE_SWITCH_DELAY_MS or PROFILE_SWITCH_MAX_RETRIES in pipewire.rs. Note: Concurrent profile switches on the same device are not supported.

4. **Regex validation**: Config validation compiles all regexes at load time. If a rule has invalid regex, daemon won't start. Be aware of catastrophic backtracking with complex patterns.

5. **Default sink requirement**: Config must have exactly one sink with `default = true`. Daemon will fail to start otherwise. This is enforced at config validation time.

6. **Unsupported compositors**: 
   - GNOME/Mutter doesn't expose window management protocols
   - KDE Plasma 6 removed the plasma-window-management protocol and hasn't implemented a replacement yet
   - These are compositor limitations, not code issues

7. **Protocol version compatibility**: The code validates Wayland protocol versions (wlr: 1-3). If a compositor advertises an incompatible version, binding will fail with a clear error.

8. **Health check timeout**: IPC health checks use a 500ms timeout to accommodate slow systems and high load scenarios. This prevents false negatives during daemon startup.

## Known Issues & Limitations

### Memory Usage
- `all_windows` HashMap duplicates some data from `active_windows` (intentional for `test-rule` command)
- IPC handlers clone config and window data on each request (not critical for single-user daemon)

### Security Notes
- Socket permissions (0o600) prevent unauthorized access on multi-user systems
- All external commands (pw-dump, pw-cli, pw-metadata) use proper JSON serialization
- No authentication beyond filesystem permissions (Unix socket is local-only)
- Complex regex patterns in rules could cause performance issues (catastrophic backtracking)

### Compositor Protocol Support

**Current Status:**
- **Supported:** `zwlr_foreign_toplevel_manager_v1` (wlroots/Smithay compositors)
- **Not Supported:** GNOME/Mutter, KDE Plasma 6

**Protocol History:**

*KDE Plasma Support (Removed December 2024):*
- Plasma 5 supported `org_kde_plasma_window_management` protocol
- Initial implementation added in v0.2.0 but marked experimental/untested
- Plasma 6 (released February 2024) removed this protocol entirely
- Support was dropped after confirming Plasma 6 has no window management protocol
- Removed files: `src/compositor/plasma.rs`, `wayland-protocols-plasma` dependency

**Future Protocol Opportunities:**

*ext-foreign-toplevel-list v1:*
- Part of official wayland-protocols (staging state)
- Intended as standardized replacement for wlr-foreign-toplevel-management
- **Key difference:** Read-only list of toplevels (no window control capabilities)
- **For pwsw:** This limitation is acceptable - we only need to monitor windows, not control them
- **Current adoption:** Minimal (as of December 2024)
- **Potential benefit:** Could enable support for KDE Plasma 6 and other compositors if/when they implement it

*Implementation considerations for ext-foreign-toplevel-list:*
1. Add dependency: `wayland-protocols` with `staging` feature enabled
2. Create new implementation: `src/compositor/ext_toplevel.rs`
3. Update protocol detection priority: wlr ‚Üí ext ‚Üí (future protocols)
4. Similar event model to wlr implementation (Opened, Changed, Closed events)
5. May need to handle different window identification schemes

**Resources:**
- wayland-protocols repository: https://gitlab.freedesktop.org/wayland/wayland-protocols
- ext-foreign-toplevel spec: `staging/ext-foreign-toplevel-list/`
- KDE Plasma 6 protocol status: Monitor KWin releases for protocol additions

**Decision rationale:**
- Hold implementation until ext-foreign-toplevel moves from staging to stable
- Ensures protocol stability and wider compositor adoption before investing effort
- Current wlr-based implementation covers majority of Wayland compositors in active use

## Code Location Quick Reference

- CLI parsing: `src/cli.rs`
- CLI command implementations: `src/commands.rs`
- Daemon entry point: `src/bin/pwsw.rs`
- State machine: `src/state.rs`
- Wayland integration: `src/compositor/mod.rs`, `src/compositor/wlr_toplevel.rs`
- PipeWire control: `src/pipewire.rs`
- IPC protocol: `src/ipc.rs`
- Config parsing: `src/config.rs`
- Notifications: `src/notification.rs`
- Terminal styling: `src/style.rs`

## Dependencies to Be Aware Of

- `wayland-client`: Handles Wayland protocol bindings (not async)
- `tokio`: Async runtime (minimal features: net, io-util, signal, sync, time)
- `regex`: Compiled once during config load, reused for all matching
- `serde_json`: Used for pw-dump parsing, IPC protocol, and secure command construction
- `notify-rust`: Desktop notifications (may fail silently if no daemon)
- `crossterm`: Terminal styling for CLI output (also used by future TUI with `ratatui`)
- `anyhow`: Error handling with context chaining (prefer over custom error types)
- External tools: `pw-dump`, `pw-metadata`, `pw-cli` (must be in PATH)

## Development Workflow

### Before Committing
1. **Format code**: `cargo fmt`
2. **Check clippy**: `cargo clippy --all-targets` (should pass cleanly)
3. **Run pedantic check**: `cargo clippy --all-targets -- -W clippy::pedantic`
4. **Validate**: `cargo run -- validate` (checks config parsing)
5. **Test manually**: Start daemon and verify affected functionality

### Code Review Checklist
When reviewing changes or adding features:
- [ ] All functions have proper documentation with `# Errors` and `# Panics` sections
- [ ] Technical terms use backticks in documentation
- [ ] No new clippy warnings introduced (beyond the 8 acceptable ones)
- [ ] Security: Proper JSON serialization for external commands
- [ ] Security: File/socket permissions set explicitly
- [ ] Error handling: Proper `Result` propagation with context
- [ ] Efficiency: Modern Rust patterns (map_or, clone_from, etc.)
- [ ] No `expect()` calls in production code paths (only defensive checks)

### Git Commit Messages
Use conventional commits format:
```
<type>: <subject>

<body>

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>
```

Types: `feat`, `fix`, `refactor`, `docs`, `chore`, `test`, `perf`

### Git Push Policy

**Push commits to remote ONLY when explicitly approved by the user.**

**NEVER push changes to remote without explicit user approval.**

When creating commits:
  1. Always create the commit locally
  2. Inform the user that the commit was created but not pushed
  3. Wait for explicit approval (e.g., "push it", "go ahead and push", "yes push") before running `git push`
  4. If approved, push with: `git push` (or `git push -u origin <branch>` for new branches)

Note: For the ongoing TUI refactor, agents and contributors must also keep `TEMP_TUI_REFACTOR.md` updated at every small step; see the AGENTS.md operational checklist.

### Testing Approach

**Automated Tests (54 total):**
Run the test suite with:
```bash
cargo test           # Run all tests
cargo test --lib     # Run unit tests only
```

Test coverage by module:
- `config.rs`: 15 tests - Config validation, sink resolution, default sink handling
- `state.rs`: 12 tests - Rule matching, priority logic, window tracking
- `pipewire.rs`: 12 tests - JSON parsing from `pw-dump` output (no external dependencies)
- `ipc.rs`: 8 tests - Request/Response serialization roundtrips
- `notification.rs`: 6 tests - Icon auto-detection for sinks and apps
- `style.rs`: 1 doctest - Styling trait usage example

All tests are inline `#[cfg(test)]` modules that test pure functions without external dependencies (no PipeWire/Wayland calls).

**Manual Testing:**
For features not covered by unit tests, manual testing should cover:
1. **Window matching**: Test regex patterns with `pwsw test-rule`
2. **Sink switching**: Verify correct sink activation with `pwsw status`
3. **IPC protocol**: Test all CLI commands while daemon is running
4. **Error conditions**: Test with missing tools, invalid config, etc.
5. **Resource cleanup**: Verify socket cleanup on daemon shutdown
