# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

PWSW (PipeWire Switcher) is a Rust daemon that automatically switches PipeWire audio sinks based on active windows in Wayland compositors. It uses standard Wayland protocols (wlr-foreign-toplevel-management and plasma-window-management) to monitor window events and PipeWire native tools (pw-dump, pw-metadata, pw-cli) for audio control.

**IMPORTANT**: This codebase was entirely generated by LLMs without peer review from experienced Rust developers. Exercise caution when making changes and validate thoroughly.

## Build Commands

### Development
```bash
# Build in debug mode
cargo build

# Build with optimizations
cargo build --release

# Check without building
cargo check

# Run tests (if any exist)
cargo test

# Run clippy for linting
cargo clippy

# Format code
cargo fmt
```

### Installation
```bash
# Install to ~/.cargo/bin/
cargo install --path .

# The binary will be at:
# - Debug: target/debug/pwsw
# - Release: target/release/pwsw
```

### Running
```bash
# Start daemon in foreground (for debugging)
cargo run -- daemon --foreground

# Start daemon in background
cargo run -- daemon

# Other commands (require running daemon for IPC commands)
cargo run -- status
cargo run -- list-sinks
cargo run -- validate
```

## Architecture

### Core Components

**Daemon Mode (`daemon.rs`)**
- Main event loop using tokio::select! to multiplex:
  - Compositor window events (via mpsc channel from Wayland thread)
  - IPC requests from CLI clients (via Unix socket)
  - Shutdown signals (Ctrl-C or IPC shutdown request)
- Owns the State and manages the lifecycle

**State Management (`state.rs`)**
- Tracks active windows that matched rules (HashMap<u64, ActiveWindow>)
- Implements rule matching logic (app_id + optional title regex)
- Priority system: most recently opened matching window wins
- When windows close or stop matching, determines target sink from remaining active windows
- Falls back to default sink when no rules match

**IPC Infrastructure (`ipc.rs`)**
- Unix socket-based client-server communication
- Length-prefixed JSON protocol (4-byte big-endian length + JSON payload)
- Socket location: $XDG_RUNTIME_DIR/pwsw.sock or /tmp/pwsw-$UID.sock
- Automatic stale socket cleanup on daemon start
- Request types: Status, Reload, ListWindows, TestRule, Shutdown
- Response types: Status, Ok, Error, Windows, RuleMatches

**Compositor Abstraction (`compositor/mod.rs`)**
- Protocol detection via Wayland registry scan (prefers wlr-foreign-toplevel over plasma)
- Spawns dedicated std::thread for Wayland event loop (Wayland is not async-friendly)
- Sends WindowEvent enum (Opened, Changed, Closed) to tokio runtime via unbounded mpsc channel
- Implementations:
  - `wlr_toplevel.rs`: wlr-foreign-toplevel-management protocol (Sway, Hyprland, Niri, River, etc.)
  - `plasma.rs`: plasma-window-management protocol (KDE Plasma/KWin)

**PipeWire Integration (`pipewire.rs`)**
- Parses pw-dump JSON output for sinks, devices, profiles, and metadata
- Active sinks: Audio/Sink nodes currently available
- Profile sinks: Predicted node names for sinks that require profile switching
- Profile switching workflow:
  1. Call pw-cli to switch device profile
  2. Wait with retries (150ms × 5 max) for new sink node to appear
  3. Set as default with pw-metadata
- Node name prediction: `alsa_output.{device_suffix}.{profile_suffix}`

**Configuration (`config.rs`)**
- TOML format at $XDG_CONFIG_HOME/pwsw/config.toml
- Validation rules:
  - Exactly one default sink required
  - No duplicate sink names or descriptions
  - All rule sink references must resolve (by position, desc, or name)
  - Log level must be valid
- Creates default config if none exists
- Sink references support: 1-indexed position, description, or node name

### Data Flow

1. **Window Event Flow**:
   - Wayland compositor emits protocol events
   - Compositor thread receives and converts to WindowEvent
   - Sent via mpsc channel to daemon's tokio runtime
   - State processes event and determines if sink switch is needed
   - PipeWire::activate_sink() called if switch required

2. **IPC Request Flow**:
   - CLI client connects to Unix socket
   - Sends length-prefixed JSON request
   - Daemon spawns tokio task to handle request
   - Task reads current state snapshot (no shared mutable state)
   - Response written back to same socket

3. **Profile Switching Flow**:
   - Check if sink is active (quick path: just set default)
   - If not active, check profile_sinks for predicted name
   - Switch device profile with pw-cli
   - Poll with retries for new sink node to appear
   - Set as default with pw-metadata

### Threading Model

- **Main Tokio Runtime**: Runs daemon event loop, IPC server, signal handlers
- **Wayland Thread**: Dedicated std::thread for Wayland event loop (blocking, not async)
- **IPC Handler Tasks**: Spawned tokio tasks for each IPC connection (non-blocking)

State is owned by the main loop. IPC handlers clone only what they need (uptime, current_sink_name, tracked windows list) to avoid shared mutable state.

### Key Design Patterns

**Priority-based sink switching**: Most recent matching window wins. When it closes, next most recent takes over.

**Predicted node names**: Profile sinks use string manipulation to predict the node name before switching (enables config validation).

**Protocol abstraction**: WindowEvent enum allows adding new compositor protocols without changing daemon logic.

**No config hot-reload**: "Reload" command validates config but requires daemon restart for changes to take effect. This avoids complex state synchronization.

## Configuration Notes

### Finding Window App IDs and Titles

Different compositors provide different tools:
- Sway/River/wlroots: `swaymsg -t get_tree`
- Hyprland: `hyprctl clients`
- Niri: `niri msg windows`
- KDE Plasma: KDE's window inspector
- Or use: `pwsw list-windows` (while daemon is running)

### Regex Pattern Syntax

Window rules support full Rust regex syntax:
- `"firefox"` - matches anywhere in string
- `"^steam$"` - exact match only
- `"^(mpv|vlc)$"` - matches mpv OR vlc
- `"(?i)discord"` - case insensitive

Both app_id and title support regex. If title is omitted, any title matches.

### Sink Icon Auto-detection

Icons are auto-detected from sink descriptions:
- "HDMI" → video-display
- "headphone" → audio-headphones
- "speaker" → audio-speakers
- "analog" → audio-card
- Override with explicit `icon = "..."` in config

## Testing

When making changes to window matching or state management logic, test with:
```bash
# Start daemon in foreground to see logs
pwsw daemon --foreground

# In another terminal:
pwsw list-windows        # See what windows daemon knows about
pwsw test-rule "^mpv$"   # Test regex patterns
pwsw status              # Check current state
```

For PipeWire integration changes:
```bash
pwsw list-sinks          # See active and profile sinks
pwsw validate            # Check config without starting daemon
```

## Common Gotchas

1. **Wayland thread panics**: The Wayland event loop runs in a separate thread. If it panics, the mpsc channel closes and daemon shuts down. Check thread spawn in compositor/mod.rs.

2. **Stale sockets**: If daemon crashes, the Unix socket may remain. Next daemon start auto-cleans stale sockets (tries to connect first).

3. **Profile switch timing**: Some audio devices take >150ms to create new sink nodes after profile switch. If switches fail, increase PROFILE_SWITCH_DELAY_MS or PROFILE_SWITCH_MAX_RETRIES in pipewire.rs.

4. **Regex validation**: Config validation compiles all regexes at load time. If a rule has invalid regex, daemon won't start.

5. **Default sink requirement**: Config must have exactly one sink with `default = true`. Daemon will fail to start otherwise.

6. **No GNOME support**: GNOME/Mutter doesn't expose window management protocols. This is a compositor limitation, not a code issue.

## Code Location Quick Reference

- CLI parsing: `src/cli.rs`
- CLI command implementations: `src/commands.rs`
- Daemon entry point: `src/bin/pwsw.rs`
- State machine: `src/state.rs`
- Wayland integration: `src/compositor/mod.rs`, `src/compositor/wlr_toplevel.rs`, `src/compositor/plasma.rs`
- PipeWire control: `src/pipewire.rs`
- IPC protocol: `src/ipc.rs`
- Config parsing: `src/config.rs`
- Notifications: `src/notification.rs`

## Dependencies to Be Aware Of

- `wayland-client`: Handles Wayland protocol bindings (not async)
- `tokio`: Async runtime (minimal features: net, io-util, signal, sync, time)
- `regex`: Compiled once during config load, reused for all matching
- `serde_json`: Used for pw-dump parsing and IPC protocol
- `notify-rust`: Desktop notifications (may fail silently if no daemon)
- External tools: `pw-dump`, `pw-metadata`, `pw-cli` (must be in PATH)
